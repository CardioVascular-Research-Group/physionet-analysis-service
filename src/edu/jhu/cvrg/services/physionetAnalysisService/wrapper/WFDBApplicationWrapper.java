package edu.jhu.cvrg.services.physionetAnalysisService.wrapper;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;

public class WFDBApplicationWrapper {
	
	private String outputFilename1 = "dummyOutput1.txt";
	private String outputFilename2 = "dummyOutput2.txt";
	private String[] outputFilenames = null;
	private boolean verbose = false;
	private BufferedReader stdInputBuffer = null;
	private BufferedReader stdError = null;
	
	/** Runs the sqrs single-channel QRS detector. 
	 * Returns a WFDB annotation file with .qrs extention,
	 * and a plain text, space delimited version of the annotations (generated by Physionet rdann function)
	 * 
	 * @param sHeaderFile - file name of the WFDB (.hea) header file of the record to analyze.
	 * @param sPath - FULL path of the header file.
	 * @param iBegin - Begin at the specified time in record (default: the beginning of record). 
	 * @param bHighrez - Read the signal files in high-resolution mode (default: standard mode). 
	 *                   These modes are identical for ordinary records. 
	 *                   For multifrequency records, the standard decimation of oversampled signals to 
	 *                   the frame rate is suppressed in high-resolution mode 
	 *                   (rather, all other signals are resampled at the highest sampling frequency). 
	 * @param iThreshold - Specify the detection threshold (default: 500 units); 
	 *                     use higher values to reduce false detections,
	 *                     or lower values to reduce the number of missed beats. 
	 * @param sSignal - Specify the signal (number or name) to be used for QRS detection (default: 0). 
	 * @param iTime - Process until the specified time in record (-1 to default, the end of the record).
	 * 
	 * @return
	 */
	public boolean sqrs(String sHeaderFile, String sPath, int iBegin, 
						boolean bHighrez, int iThreshold, String sSignal, int iTime){
		boolean bRet = true;
		debugPrintln("sqrs()");
		debugPrintln("- sHeaderFile:" + sHeaderFile);
		debugPrintln("- sPath:" + sPath);
		debugPrintln("- iBegin:" + iBegin);
		debugPrintln("- bHighrez:" + bHighrez);
		debugPrintln("- iThreshold:" + iThreshold);
		debugPrintln("- sSignal:" + sSignal);
		debugPrintln("- iTime:" + iTime);
		try {
			
			// no environment variables are needed, 
			// this is a place keeper so that the three parameter version of
			// exec can be used to specify the working directory.
			String[] asEnvVar = new String[0];  
			
			// build command string
			int iIndexPeriod = sHeaderFile.lastIndexOf(".");
			String sRecord = sHeaderFile.substring(0, iIndexPeriod);
			
			String sCommand = "sqrs -r " + sRecord;
			if(iBegin !=0) sCommand += " -f " + iBegin;
			if(bHighrez) sCommand += " -H ";
			if(iThreshold != 500) sCommand += " -m " + iThreshold;
			if(sSignal.equals("0")) sCommand += " -s " + sSignal;
			if(iTime != -1) sCommand += " -t " + iTime;
	
			bRet = executeCommand(sCommand, asEnvVar, sPath);
			stdReturnHandler();
			
			if(bRet){
				outputFilename1 = sPath + "/" + sRecord + ".qrs";
			}else{
				debugPrintln("- Encountered errors.");
			}
			
		} catch (IOException e) {
			bRet = false;
			e.printStackTrace();
		}

		return bRet;
	}

	/** Runs the wqrs single-channel QRS detector. 
	 * Returns a WFDB annotation file with .wqrs extention,
	 * and a plain text, space delimited version of the annotations (generated by Physionet rdann function)
	 * 
	 * @param sHeaderFile - file name of the WFDB (.hea) header file of the record to analyze.
	 * @param sPath - FULL path of the header file.
	 * @param iBegin - Begin at the specified time in record (default: the beginning of record). 
	 * @param bHighrez - Read the signal files in high-resolution mode (default: standard mode). 
	 *                   These modes are identical for ordinary records. 
	 *                   For multifrequency records, the standard decimation of oversampled signals to 
	 *                   the frame rate is suppressed in high-resolution mode 
	 *                   (rather, all other signals are resampled at the highest sampling frequency). 
	 * @param iThreshold - Specify the detection threshold (default: 500 units); 
	 *                     use higher values to reduce false detections,
	 *                     or lower values to reduce the number of missed beats. 
	 * @param sSignal - Specify the signal (number or name) to be used for QRS detection (default: 0). 
	 * @param iTime - Process until the specified time in record (-1 to default, the end of the record).
	 * 
	 * @return
	 */
	public boolean wqrs(String sHeaderFile, String sPath, 
			boolean bDumpRaw, int iBegin, boolean bPrintHelp, boolean bHighrez, boolean bFindJPoints, int iThreshold, 
			int iPowerFreq, boolean bResample, String sSignal, int iTime, boolean bVerbose){
		boolean bRet = true;
		debugPrintln("wqrs()");
		debugPrintln("- sHeaderFile:" + sHeaderFile);
		debugPrintln("- sPath:" + sPath);
		debugPrintln("- iBegin:" + iBegin);
		debugPrintln("- bHighrez:" + bHighrez);
		debugPrintln("- iThreshold:" + iThreshold);
		debugPrintln("- sSignal:" + sSignal);
		debugPrintln("- iTime:" + iTime);
		try {
			// no environment variables are needed, 
			// this is a place keeper so that the three parameter version of
			// exec can be used to specify the working directory.
			String[] asEnvVar = new String[0];  
			
			// build command string
			int iIndexPeriod = sHeaderFile.lastIndexOf(".");
			String sRecord = sHeaderFile.substring(0, iIndexPeriod);
			
			String sCommand = "wqrs -r " + sRecord;
			if(bDumpRaw) sCommand   += " -d ";
			if(iBegin !=0) sCommand += " -f " + iBegin;
			if(bPrintHelp) sCommand += " -h ";
			if(bHighrez) sCommand   += " -H ";
			if(bFindJPoints) sCommand += " -j ";
			if(iThreshold != 500) sCommand += " -m " + iThreshold;
			if(iPowerFreq !=60) sCommand += " -p " + iPowerFreq;
			if(bResample) sCommand += " -R ";
			if(sSignal.equals("0")) sCommand += " -s " + sSignal;
			if(iTime != -1) sCommand += " -t " + iTime;
			if(bVerbose) sCommand += " -v ";
	
			bRet = executeCommand(sCommand, asEnvVar, sPath);
			stdReturnHandler();
			debugPrintln("-------------");
			
			if(bRet){
				//set first output file to the annotation (.wqrs) file generated by the sqrs command
				outputFilename1 = sPath + "/" + sRecord + ".wqrs";

				sCommand = "rdann -a wqrs -r " + sRecord + " > " + sRecord + "_wqrs.txt";
				bRet = executeCommand(sCommand, asEnvVar, sPath);
				stdReturnHandler();
				debugPrintln("-------------");

				// set second output filename to the text file generated by rdann command.
				outputFilename2 = sPath + "/" + sRecord + "_wqrs.txt";
			}else{
				debugPrintln("- Encountered errors.");
			}
			
		} catch (IOException e) {
			bRet = false;
			e.printStackTrace();
		}

		return bRet;
	}


	
	/** Runs the sqrs single-channel QRS detector. 
	 * Returns a WFDB annotation file with .qrs extention,
	 * and a plain text, space delimited version of the annotations (generated by Physionet rdann function)
	 * 
	 * @param sHeaderFile - file name of the WFDB (.hea) header file of the record to analyze.
	 * @param sPath - FULL path of the header file.
	 * @param iBegin - Begin at the specified time in record (default: the beginning of record). 
	 * @param bHighrez - Read the signal files in high-resolution mode (default: standard mode). 
	 *                   These modes are identical for ordinary records. 
	 *                   For multifrequency records, the standard decimation of oversampled signals to 
	 *                   the frame rate is suppressed in high-resolution mode 
	 *                   (rather, all other signals are resampled at the highest sampling frequency). 
	 * @param iThreshold - Specify the detection threshold (default: 500 units); 
	 *                     use higher values to reduce false detections,
	 *                     or lower values to reduce the number of missed beats. 
	 * @param sSignal - Specify the signal (number or name) to be used for QRS detection (default: 0). 
	 * @param iTime - Process until the specified time in record (-1 to default, the end of the record).
	 * 
	 * @return
	 */
	public boolean ecgpuwave (String sHeaderFile, String sPath, int iBegin, String sInputAnnotator,
								int iBeatType, String sSignal, int iTime){
		boolean bRet = true;
		debugPrintln("ecgpuwave ()");
		debugPrintln("- sHeaderFile:" + sHeaderFile);
		debugPrintln("- sPath:" + sPath);
		debugPrintln("- iBegin:" + iBegin);
		debugPrintln("- sInputAnnotator:" + sInputAnnotator);
		debugPrintln("- iBeatType:" + iBeatType);
		debugPrintln("- sSignal:" + sSignal);
		debugPrintln("- iTime:" + iTime);
		try {
			
			// no environment variables are needed, 
			// this is a place keeper so that the three parameter version of
			// exec can be used to specify the working directory.
			String[] asEnvVar = new String[0];  
			
			// build command string
			int iIndexPeriod = sHeaderFile.lastIndexOf(".");
			String sRecord = sHeaderFile.substring(0, iIndexPeriod);
			
			String sCommand = "ecgpuwave -r " + sRecord;
			if(iBegin !=0) sCommand += " -f " + iBegin;
			if(!sInputAnnotator.equals("")){
				sCommand += " -i " + sInputAnnotator;
				// (must be used together with -i)
				if(iBeatType !=0) sCommand += " -n 1 "; 
			}
			if(!sSignal.equals("0")) sCommand += " -s " + sSignal;
			if(iTime != -1) sCommand += " -t " + iTime;
	
			bRet = executeCommand(sCommand, asEnvVar, sPath);
			stdReturnHandler();
			bRet &= stdErrorHandler();
			
			if(bRet){
				//set first output file to the annotation (.qrs) file generated by the sqrs command
				outputFilename1 = sPath + "/" + sRecord + ".qrs";

				sCommand = "rdann -a qrs -r " + sRecord + " > " + sRecord + ".txt";
				bRet = executeCommand(sCommand, asEnvVar, sPath);
				stdReturnHandler();
				bRet &= stdErrorHandler();
				// set second output filename to the text file generated by rdann command.
				outputFilename2 = sPath + "/" + sRecord + ".txt";
			}else{
				debugPrintln("- Encountered errors.");
			}
			
		} catch (IOException e) {
			bRet = false;
			e.printStackTrace();
		}

		return bRet;
	}

	

	/** Runs the Physionet sigamp tool to measure signal amplitudes of a WFDB record.  
	 * sigamp measures either baseline-corrected RMS amplitudes or (for suitably annotated ECG signals) 
	 * normal QRS peak-to-peak amplitudes for all signals of the specified record. 
	 * It makes up to 300 measurements (but see iNmax (-n) below) for each signal and calculates trimmed means 
	 * (by discarding the largest and smallest 5% of the measurements and taking the mean of the remaining 90%). 
	 * 
	 * @param sHeaderFile - file name of the WFDB (.hea) header file of the record to analyze.
	 * @param sPath - FULL path of the header file.
	 * @param iBegin - Begin at the specified time in record (default: the beginning of record). 
	 * @param sInputAnnotator - Measure QRS peak-to-peak amplitudes based on normal QRS annotations from the specified annotator. 
	 * @param dDeltaMeasureStart - Set the Beginning of measurement window in seconds before QRS annotations.
	 * @param dDeltaMeasureEnd -   Set the Ending of measurement window in seconds after QRS annotations.
	 * @param bHighrez - Read the signal files in high-resolution mode (default: standard mode). 
	 *                   These modes are identical for ordinary records. 
	 *                   For multifrequency records, the standard decimation of oversampled signals to 
	 *                   the frame rate is suppressed in high-resolution mode 
	 *                   (rather, all other signals are resampled at the highest sampling frequency). 
	 * @param iNmax - Make up to nmax measurements on each signal (default: 300). 
	 * @param iTime - Process until the specified time in record (-1 to default, the end of the record) Processing will be terminated prematurely if 250 measurements are made before reaching the specified time.
	 * @param fDeltaTimeWin- Set RMS amplitude measurement window in seconds. Default: dtw = 1 (second). 
	 * @param bVerbose - Verbose mode: return individual measurements as well as trimmed means. 
	 * @param bQuickmode - Quick mode: return individual measurements only. 
	 * @param bPrintPhysicalUnits - return results in physical units, time in seconds, same as -ps (default: ADC units)
	 * @param bPrintDay - return physical units + time of day and date if known
	 * @param bPrintElapsed - return physical units + elapsed time as <hours>:<minutes>:<seconds>
	 * @param bPrintHours - return physical units + elapsed time in hours
	 * @param bPrintMinutes - return physical units + elapsed time in minutes
	 * @param bPrintSeconds - return physical units + elapsed time in seconds (default)
	 * @param bPrintSamples - return physical units + elapsed time in sample intervals
	 * 
	 * @return
	 */
	public boolean sigamp(String sHeaderFile, String sPath, 
								int iBegin, String sInputAnnotator, double dDeltaMeasureStart, double dDeltaMeasureEnd, boolean bHighRez,
								int iNmax, int iTime, double dDeltaTimeWin,
								boolean bVerbose, boolean bQuickmode,
								boolean bPrintPhysicalUnits, boolean bPrintDay, boolean bPrintElapsed, 
								boolean bPrintHours, boolean bPrintMinutes, boolean bPrintSeconds, boolean bPrintSamples){
		boolean bRet = true;
		debugPrintln("sigamp()");
		debugPrintln("- sHeaderFile:" + sHeaderFile);
		debugPrintln("- sPath:" + sPath);
		debugPrintln("- iBegin:" + iBegin);
		debugPrintln("- sInputAnnotator:" + sInputAnnotator); // Measure QRS peak-to-peak amplitudes based on normal QRS annotations from the specified annotator. 
		debugPrintln("- fdt1:" + dDeltaMeasureStart);
		debugPrintln("- fdt2:" + dDeltaMeasureEnd);
		debugPrintln("- bHighRez:" + bHighRez);
		debugPrintln("- iNmax:" + iNmax); // Make up to nmax measurements on each signal (default: 300). 
		debugPrintln("- iTime:" + iTime); // Process until the specified time in record (-1 to default, the end of the record) Processing will be terminated prematurely if 250 measurements are made before reaching the specified time.
		debugPrintln("- fDeltaTimeWin:" + dDeltaTimeWin); // Set RMS amplitude measurement window. Default: dtw = 1 (second). 
		//--  output adjustments
		debugPrintln("- bVerbose:" + bVerbose); // Verbose mode: print individual measurements as well as trimmed means. 
		debugPrintln("- bQuickmode:" + bQuickmode); // Quick mode: print individual measurements only. 
		debugPrintln("- bPrintPhysicalUnits:" + bPrintPhysicalUnits); //  print results in physical units, time in seconds, same as -ps (default: ADC units)
		debugPrintln("- bPrintDay:" + bPrintDay); // print physical units + time of day and date if known
		debugPrintln("- bPrintElapsed:" + bPrintElapsed); // print physical units + elapsed time as <hours>:<minutes>:<seconds>
		debugPrintln("- bPrintHours:" + bPrintHours);// print physical units + elapsed time in hours
		debugPrintln("- bPrintMinutes:" + bPrintMinutes); // print physical units + elapsed time in minutes
		debugPrintln("- bPrintSeconds:" + bPrintSeconds); // print physical units + elapsed time in seconds (default)
		debugPrintln("- bPrintSamples:" + bPrintSamples); // print physical units + elapsed time in sample intervals


		try {
			
			// no environment variables are needed, 
			// this is a place keeper so that the three parameter version of
			// exec can be used to specify the working directory.
			String[] asEnvVar = new String[0];  
			
			// build command string
			int iIndexPeriod = sHeaderFile.lastIndexOf(".");
			String sRecord = sHeaderFile.substring(0, iIndexPeriod);
			
			String sCommand = "sigamp -r " + sRecord; // record name (same as header file name.)
			if(iBegin !=0) sCommand += " -f " + iBegin;
			if(!sInputAnnotator.equals("")){
				sCommand += " -a " + sInputAnnotator; // Measure QRS peak-to-peak amplitudes based on normal QRS annotations from the specified annotator. 
			}
			// ( -d option must be used with -a;)
			if((dDeltaMeasureStart != 0.05)|| (dDeltaMeasureEnd != 0.05)) sCommand += " -a " + dDeltaMeasureStart + " " + dDeltaMeasureEnd; // Set the measurement window relative to QRS annotations. 
			if(bHighRez) sCommand += " -H "; // Read the signal files in high-resolution mode (default: standard mode).
			if(iNmax !=300) sCommand += " -n " + iNmax; // Make up to nmax measurements on each signal (default: 300).			
			if(iTime != -1) sCommand += " -t " + iTime; // Process until the specified time in record (default: the end of the record). Processing will be terminated prematurely if 250 measurements are made before reaching the specified time. 
			if(dDeltaTimeWin !=1.0) sCommand += " -w " + dDeltaTimeWin; //Set RMS amplitude measurement window in seconds. Default: dtw = 1 (second). 
			//--  output adjustments
			if(bVerbose) sCommand += " -v "; //Verbose mode: print individual measurements as well as trimmed means. 
			if(bQuickmode) sCommand += " -q "; // Quick mode: print individual measurements only, not trimmed means.
			if(bPrintPhysicalUnits) sCommand += " -p ";//  print results in physical units, time in seconds, same as -ps(default: ADC units)
			if(bPrintDay) sCommand += " -pd ";// print physical units + time of day and date if known
			if(bPrintElapsed) sCommand += " -pe ";//print physical units + elapsed time as <hours>:<minutes>:<seconds>
			if(bPrintHours) sCommand += " -ph ";// print physical units + elapsed time in hours
			if(bPrintMinutes) sCommand += " -pm ";//print physical units + elapsed time in minutes
			if(bPrintSeconds) sCommand += " -ps ";// print physical units + elapsed time in seconds (default, same as -p)
			if(bPrintSamples) sCommand += " -pS ";// print physical units + elapsed time in sample intervals

			bRet = executeCommand(sCommand, asEnvVar, sPath);
			stdReturnHandler(sPath + "/" + sRecord + ".txt");
			bRet &= stdErrorHandler();
			
			if(bRet){
				//set first output file to output generated by the sigamp command
				outputFilename1 = sPath + "/" + sRecord + ".txt";
			}else{
				debugPrintln("- Encountered errors.");
			}
			
		} catch (IOException e) {
			bRet = false;
			e.printStackTrace();
		}

		return bRet;
	}

	/** Runs the Physionet rdsamp tool to read and display WFDB records.  
	 * rdsamp reads signal files for the specified record and writes the samples as decimal numbers on the standard output. 
	 * If no options are provided, rdsamp starts at the beginning of the record and prints all samples. 
	 * By default, each line of output contains the sample number and samples from each signal, 
	 * beginning with channel 0, separated by tabs. 
	 * 
	 * @param sHeaderFile - file name of the WFDB (.dat) signal file to analyze.
	 * @param sPath - Produce output in CSV (comma-separated value) format (default: write output in tab-separated columns).
	 * @param bCsv - Begin at the specified time in record (default: the beginning of record). 
	 * @param iStarttime - Begin at the specified time. By default, rdsamp starts at the beginning of the record.  
	 * @param bSummary - Set the Beginning of measurement window in seconds before QRS annotations.
	 * @param bHighrez - Read the signal files in high-resolution mode (default: standard mode). 
	 *                   These modes are identical for ordinary records. 
	 *                   For multifrequency records, the standard decimation of oversampled signals to 
	 *                   the frame rate is suppressed in high-resolution mode 
	 *                   (rather, all other signals are resampled at the highest sampling frequency). 
	 * @param dInterval - Limit the amount of output to the specified time interval 
	 * 					 (in standard time format; default: no limit). 
	 * 					 If both -l and -t are used, rdsamp stops at the earlier of the two limits. 
	 * @param bSeconds - Print times in seconds and milliseconds, and values in physical units. By default, rdsamp prints times in sample intervals and values in A/D units.
	 * @param bHighprecision - Same as -p, but yields higher precision in the sample values (8 decimal places rather than 3).
	 * 						   A single character can be attached to either -p or -P to choose the
	 * 						   format for the printed times in the first column of output. The choices are: 
	 * @param sSignallist - Print only the signals named in the signal-list (one or more input signal numbers or names, separated by spaces; 
	 * 						default: print all signals). This option may be used to re-order or duplicate signals. 
	 * @param sFirstsignal - Search for the first valid sample of the specified signal (a signal name or number) at or following the time specified with -f 
	 * 						 (or the beginning of the record if the -f option is not present), and begin printing at that time. 
	 * @param iEndtime - Process until the specified time in record (-1 to default, the end of the record) Processing will be terminated prematurely if 250 measurements are made before reaching the specified time. 
	 * @param bColumnheads - Print column headings (signal names on the first line, units on the second). 
	 * 						 The names of some signals are too wide to fit in the columns; such names are shortened by omitting the initial characters 
	 * 						 (since names of related signals often differ only at the end, this helps to make the columns identifiable). 
	 * 						 Names of units are shortened when necessary by omitting the final characters, since the initial characters are usually most important for distinguishing different units.  
	 * @param bXML - Produce output in WFDB-XML format (same as the CSV format produced using the -c option, but wrapped within an XML header and trailer). 
	 * 				 This format is recognized and parsed automatically by wrsamp. 
	 * @param sOutputFile

	 * 
	 * @return
	 */
	public boolean rdsamp(String sHeaderFile, String sPath, 
								boolean bCsv, int iStarttime, boolean bSummary, boolean bHighrez, double dInterval,
								String sFormatOutput, String sSignallist, String sFirstsignal,
								int iEndtime, boolean bColumnheads, boolean bXML){
		boolean bRet = true;
		debugPrintln("rdsamp()");
		debugPrintln("- sHeaderFile: " + sHeaderFile);
		debugPrintln("- sPath: " + sPath);
		debugPrintln("- bCsv: " + bCsv);
		debugPrintln("- iStarttime: " + iStarttime);  
		debugPrintln("- bSummary: " + bSummary);
		debugPrintln("- bHighrez: " + bHighrez);
		debugPrintln("- dInterval: " + dInterval);
		debugPrintln("- sFormatOutput: " + sFormatOutput); 
		debugPrintln("- sSignallist: " + sSignallist); 
		debugPrintln("- sFirstSignal: " + sFirstsignal); 
		debugPrintln("- iEndtime: " + iEndtime);
		//--  output adjustments
		debugPrintln("- bColumnheads: " + bColumnheads);  
		debugPrintln("- bXML: " + bXML);  

		try {
		
			String[] asEnvVar = new String[0];  
			
			// build command string
			int iIndexPeriod = sHeaderFile.lastIndexOf(".");
			String sRecord = sHeaderFile.substring(0, iIndexPeriod);
			
			String sOutputFile = sRecord;
			
			String sCommand = "rdsamp -r " + sRecord; // record name
			if(bCsv) sCommand += " -c"; // CSV Format
			if(iStarttime > 0) sCommand += " -f " + iStarttime;
			if(bSummary) sCommand += " -h";	
			if(bHighrez) sCommand += " -H";
			if(dInterval > 0) sCommand += " -c " + dInterval;
			
			// one of the following: pd, pe, ph, pm, ps, pS, Pd, Pe, Ph, Pm, Ps, PS
			if(!sFormatOutput.equals("")) sCommand += " -" + sFormatOutput; 
			
			if(!sSignallist.equals("")) sCommand += " -s " + sSignallist;
			if(!sFirstsignal.equals("")) sCommand += " -S " + sFirstsignal;
			if(iEndtime > 0) sCommand += " -t " + iEndtime;
			if(bColumnheads) sCommand += " -v";
			if(bXML) sCommand += " -X"; //Produce output in WFDB-XML format 

			if (bCsv)
			{
				sOutputFile += "_rdsamp" + ".csv";
			}
			else if (bXML)
			{
				sOutputFile += "_rdsamp" + ".xml";
			}
			else
			{
				sOutputFile += "_rdsamp" + ".txt";
			}			
			debugPrintln("- sOutputFile: " + sOutputFile);  

			// essentially, we will be trying to stream the data and write it line by line to the output file as we receive it
			
			bRet = executeCommand(sCommand, asEnvVar, sPath);			
			
			stdReturnHandler(sPath + sOutputFile);

//			bRet &= 
			stdErrorHandler(); // always seem to get "getvec: checksum error . . ."

			if(bRet){
				//set first output file to output generated by the sigamp command
				outputFilenames = new String[1];
				outputFilenames[0] = sPath + sOutputFile;
			}else{
				debugPrintln("- Encountered errors.");
			}			
			
		} catch (IOException e) {
			bRet = false;
			e.printStackTrace();
		}

		return bRet;
	}
	
	/** Runs the Physionet wrsamp tool to take in text input and convert it into a WFDB record.
	 * 
     * wrsamp reads text-format input and writes the specified columns in WFDB signal file format 16 (see signal(5) ), either to the standard output or to a disk file (see the -o option below). 
     * If no columns are specified, all columns are written (but see the -z option below).
     * Normally, wrsamp's input is line- and column-oriented, with line separator characters (usually ASCII linefeeds) separating input lines, and field separator characters (usually tabs, spaces, or commas) separating columns within each line. 
     * Columns need not be of constant width; the only requirement is that one or more field separator characters appear between adjacent columns. 
     * The output of rdsamp(1) is an example of an acceptable input format, as is CSV (comma-separated value) format.  
     * If the first input line contains any alphabetic character, it is assumed to contain signal names (column headings), and these are copied to the output header file (see the -o option below). 
     * In this case, if the second input line also contains any alphabetic character, it is assumed to contain unit names (i.e., the names of the physical units of each signal), and these are also copied to the output header file. 
     * Spaces embedded within unit names are written as underscores in the header file.
     * Lines are identified by line number. The first line of input not containing any alphabetic character is line 0. Similarly, columns are identified by column number, and the leftmost column is column 0. 
     * Columns may be selected in any order, and any given column may be selected more than once, or omitted. The order of column arguments determines the order of the signals in the output (data from the first column specified are written as signal 0, etc.) 
     * If an entry in a specified column is "-" (i.e., flagged as missing or invalid), or if an entry in a specified column is any other non-numeric value, wrsamp records it as an invalid sample in its output.
     * If line 0 appears to begin with a timestamp (a field of the form [hh:mm:ss.sss dd/mm/yyyy]), wrsamp records it as the base time (starting time) in the output header file. 
	 * 
	 * @param sInputFile - file name of the text file signal file to analyze.
	 * @param sPath - Produce output in CSV (comma-separated value) format (default: write output in tab-separated columns).
	 * @param bCheckInput - Check that each input line contains the same number of fields. (This test is normally disabled, to allow for input files containing preambles, trailers, or occasional extra fields not intended to be read as samples.)  
	 * @param bDither - Dither the input before converting it to integer output, by adding a random value to each sample. The random values are selected from a triangular probability density function between -1 and +1. Dithering is appropriate whenever the output has a lower resolution than the input. Note that the RNG used to generate the pseudo-random values is started with a fixed seed, so that wrsamp�s output is strictly reproducible. 
	 *                  Change the seed in the source and recompile to obtain a different realization of dither if desired.  
	 * @param iCopyStart - Start copying with line n. By default, wrsamp starts at the beginning of its standard input (line 0).
	 * @param iSampleFrequency - Specify the sampling frequency (in samples per second per signal) for the output signals (default: 250). This option is useful only in conjunction with -o, since it affects the output header file only. 
	 *                           This option has no effect on the output signal file, which contains one sample per signal for each line of input. 
	 *                           If you wish to change the sampling frequency in the signal file, see xform(1) . 
	 * @param bSummary - Specify the gain (in A/D units per millivolt) for the output signals (default: 200). 
	 *                   To specify different gains for each output signal, provide a quoted list of values in place of n (see the examples below). 
	 *                   This option is useful only in conjunction with -o, since it affects the output header file only. 
	 *                   This option has no effect on the output signal file. If you wish to rescale samples in the signal file, use -x.  
	 * @param iCharacters - Same as -p, but yields higher precision in the sample values (8 decimal places rather than 3).
	 * 						   A single character can be attached to either -p or -P to choose the
	 * 						   format for the printed times in the first column of output. The choices are: 
	 * @param sRecordName - Print only the signals named in the signal-list (one or more input signal numbers or names, separated by spaces; 
	 * 						default: print all signals). This option may be used to re-order or duplicate signals. 
	 * @param sFormat - Search for the first valid sample of the specified signal (a signal name or number) at or following the time specified with -f 
	 * 						 (or the beginning of the record if the -f option is not present), and begin printing at that time. 
	 * @param cLineSeparator - Process until the specified time in record (-1 to default, the end of the record) Processing will be terminated prematurely if 250 measurements are made before reaching the specified time. 
	 * @param cFieldSeparator - Print column headings (signal names on the first line, units on the second). 
	 * 						 The names of some signals are too wide to fit in the columns; such names are shortened by omitting the initial characters 
	 * 						 (since names of related signals often differ only at the end, this helps to make the columns identifiable). 
	 * 						 Names of units are shortened when necessary by omitting the final characters, since the initial characters are usually most important for distinguishing different units.  
	 * @param iLineStop - Produce output in WFDB-XML format (same as the CSV format produced using the -c option, but wrapped within an XML header and trailer). 
	 * 				 This format is recognized and parsed automatically by wrsamp. 
	 * @param dMultiply - Produce output in WFDB-XML format (same as the CSV format produced using the -c option, but wrapped within an XML header and trailer).
	 * @param bNoZero - Produce output in WFDB-XML format (same as the CSV format produced using the -c option, but wrapped within an XML header and trailer).    
	 * @param sOutputFile
	 * 
	 * Note:  The input file from the -i is not necessary.  The default input is from the stdin.  
	 *        Also, since input and output files are passed in from the web service, this function will be reworked to take those values in as parameters instead of in the form the
	 *        man page uses.  The command string will be built here.
	 *        Also note that we will need to create canned data for now until we get version 2 of the rdsamp function working (or the file output from version 1). 

	 * 
	 * @return
	 */
	public boolean wrsamp(String sInputFile, String sPath, 
								boolean bCheckInput, boolean bDither, int iCopyStart, int iSampleFrequency,
								int iCharacters, String sRecordName, String sFormat,
								char cLineSeparator, char cFieldSeparator, int iLineStop, double dMultiply, boolean bNoZero, String sOutputName){
		boolean bRet = true;
		debugPrintln("wrsamp()");
		debugPrintln("- sInputFile:" + sInputFile);
		debugPrintln("- sPath:" + sPath);
		debugPrintln("- bCheckInput:" + bCheckInput);
		debugPrintln("- bDither:" + bDither);  
		debugPrintln("- iCopyStart:" + iCopyStart);
		debugPrintln("- iSampleFrequency:" + iSampleFrequency);
		debugPrintln("- iCharacters:" + iCharacters); 
		debugPrintln("- sRecordName:" + sRecordName); 
		debugPrintln("- sFormat:" + sFormat); 
		debugPrintln("- cLineSeparator:" + cLineSeparator);
		debugPrintln("- cFieldSeparator:" + cFieldSeparator);  
		debugPrintln("- iLineStop:" + iLineStop);
		debugPrintln("- dMultiply:" + dMultiply);
		debugPrintln("- bNoZero:" + bNoZero);		
		debugPrintln("- sOutputName:" + sOutputName);

		try {
		
			String[] asEnvVar = new String[0];  
			
			// build command string
			
			//sOutputFile = sRecord;
			
			String sCommand = "wrsamp -i " + sInputFile; // record name
			if(bCheckInput) sCommand += " -c";
			if(bDither) sCommand += " -d ";
			if(iCopyStart > 0 ) sCommand += " -f " + iCopyStart;	
			if(iSampleFrequency > 0) sCommand += " -F " + iSampleFrequency;
			if(iCharacters > 0) sCommand += " -l " + iCharacters;
			if(dMultiply > 0) sCommand += " -x " + dMultiply;
			
			// the -o is a required parameter, the default is the input filename.
			if(sOutputName.equals(""))
			{
				int iIndexPeriod = sInputFile.lastIndexOf(".");
				sOutputName = sInputFile.substring(0, iIndexPeriod);
			}
			
			sCommand += " -o " + sOutputName + "_wrsamp";
						
			if(cLineSeparator != '\u0000') sCommand += " -r " + cLineSeparator; // \u0000 is the empty char.  It is used since an empty char of '' cannot be declared in Java
			if(cFieldSeparator != '\u0000') sCommand += " -s " + cFieldSeparator;
			if(iLineStop > 0) sCommand += " -t " + iLineStop;
			if(bNoZero) sCommand += " -z";

			// essentially, we will be trying to stream the data and write it line by line to the output file as we receive it
			
			bRet = executeCommand(sCommand, asEnvVar, sPath);			

			if(bRet){
				//set first output file to output generated by the sigamp command
				outputFilenames = new String[2];
				outputFilenames[0] = sPath + "/" + sOutputName + ".dat";
				outputFilenames[1] = sPath + "/" + sOutputName + ".hea";
			}else{
				debugPrintln("- Encountered errors.");
			}			
			
		} catch (Exception e) {
			bRet = false;
			e.printStackTrace();
		}

		return bRet;
	}	

	/** Runs the Physionet wrsamp tool to take in text input and convert it into a WFDB record.
	 * 
     * wrsamp reads text-format input and writes the specified columns in WFDB signal file format 16 (see signal(5) ), either to the standard output or to a disk file (see the -o option below). 
     * If no columns are specified, all columns are written (but see the -z option below).
     * Normally, wrsamp's input is line- and column-oriented, with line separator characters (usually ASCII linefeeds) separating input lines, and field separator characters (usually tabs, spaces, or commas) separating columns within each line. 
     * Columns need not be of constant width; the only requirement is that one or more field separator characters appear between adjacent columns. 
     * The output of rdsamp(1) is an example of an acceptable input format, as is CSV (comma-separated value) format.  
     * If the first input line contains any alphabetic character, it is assumed to contain signal names (column headings), and these are copied to the output header file (see the -o option below). 
     * In this case, if the second input line also contains any alphabetic character, it is assumed to contain unit names (i.e., the names of the physical units of each signal), and these are also copied to the output header file. 
     * Spaces embedded within unit names are written as underscores in the header file.
     * Lines are identified by line number. The first line of input not containing any alphabetic character is line 0. Similarly, columns are identified by column number, and the leftmost column is column 0. 
     * Columns may be selected in any order, and any given column may be selected more than once, or omitted. The order of column arguments determines the order of the signals in the output (data from the first column specified are written as signal 0, etc.) 
     * If an entry in a specified column is "-" (i.e., flagged as missing or invalid), or if an entry in a specified column is any other non-numeric value, wrsamp records it as an invalid sample in its output.
     * If line 0 appears to begin with a timestamp (a field of the form [hh:mm:ss.sss dd/mm/yyyy]), wrsamp records it as the base time (starting time) in the output header file. 
	 * 
	 * @param sInputFile - file name of the text file signal file to analyze.
	 * @param sPath - Produce output in CSV (comma-separated value) format (default: write output in tab-separated columns).
	 * @param sAnnotator - Check that each input line contains the same number of fields. (This test is normally disabled, to allow for input files containing preambles, trailers, or occasional extra fields not intended to be read as samples.)  
	 * @param iStartTime - Dither the input before converting it to integer output, by adding a random value to each sample. The random values are selected from a triangular probability density function between -1 and +1. Dithering is appropriate whenever the output has a lower resolution than the input. Note that the RNG used to generate the pseudo-random values is started with a fixed seed, so that wrsamp�s output is strictly reproducible. 
	 *                  Change the seed in the source and recompile to obtain a different realization of dither if desired.  
	 * @param iSampleFrequency - Start copying with line n. By default, wrsamp starts at the beginning of its standard input (line 0).
	 * @param bSummary - Specify the sampling frequency (in samples per second per signal) for the output signals (default: 250). This option is useful only in conjunction with -o, since it affects the output header file only. 
	 *                           This option has no effect on the output signal file, which contains one sample per signal for each line of input. 
	 *                           If you wish to change the sampling frequency in the signal file, see xform(1) . 
	 * @param iRate - Specify the gain (in A/D units per millivolt) for the output signals (default: 200). 
	 *                   To specify different gains for each output signal, provide a quoted list of values in place of n (see the examples below). 
	 *                   This option is useful only in conjunction with -o, since it affects the output header file only. 
	 *                   This option has no effect on the output signal file. If you wish to rescale samples in the signal file, use -x.  
	 * @param iDuration - Same as -p, but yields higher precision in the sample values (8 decimal places rather than 3).
	 * 						   A single character can be attached to either -p or -P to choose the
	 * 						   format for the printed times in the first column of output. The choices are: 
	 * @param iSamples - Print only the signals named in the signal-list (one or more input signal numbers or names, separated by spaces; 
	 * 						default: print all signals). This option may be used to re-order or duplicate signals. 
	 * @param bOutlier - Search for the first valid sample of the specified signal (a signal name or number) at or following the time specified with -f 
	 * 						 (or the beginning of the record if the -f option is not present), and begin printing at that time. 
	 * @param iSmoothing - Process until the specified time in record (-1 to default, the end of the record) Processing will be terminated prematurely if 250 measurements are made before reaching the specified time. 
	 * @param iEndTime - Print column headings (signal names on the first line, units on the second). 
	 * 						 The names of some signals are too wide to fit in the columns; such names are shortened by omitting the initial characters 
	 * 						 (since names of related signals often differ only at the end, this helps to make the columns identifiable). 
	 * 						 Names of units are shortened when necessary by omitting the final characters, since the initial characters are usually most important for distinguishing different units.  
	 * @param bSampleNumber - Produce output in WFDB-XML format (same as the CSV format produced using the -c option, but wrapped within an XML header and trailer). 
	 * 				 This format is recognized and parsed automatically by wrsamp. 
	 * @param bOutputSeconds1 - Produce output in WFDB-XML format (same as the CSV format produced using the -c option, but wrapped within an XML header and trailer).
	 * @param bOutputSeconds2 - Produce output in WFDB-XML format (same as the CSV format produced using the -c option, but wrapped within an XML header and trailer).    
	 * @param sOutputFile
	 * 
	 * Note:  The input file from the -i is not necessary.  The default input is from the stdin.  
	 *        Also, since input and output files are passed in from the web service, this function will be reworked to take those values in as parameters instead of in the form the
	 *        man page uses.  The command string will be built here.
	 *        Also note that we will need to create canned data for now until we get version 2 of the rdsamp function working (or the file output from version 1). 

	 * 
	 * @return
	 */
	public boolean tach(String sInputFile, String sPath, 
			String sAnnotator, int iStartTime, int iSampleFrequency, int iRate,
			int iDuration, int iSamples, boolean bOutlier,
			int iSmoothing, int iEndTime, boolean bSampleNumber, boolean bOutputSeconds1, boolean bOutputMinutes, boolean bOutputHours, String sOutputName){
		boolean bRet = true;
		debugPrintln("tach()");
		debugPrintln("- sInputFile:" + sInputFile);
		debugPrintln("- sPath:" + sPath);
		debugPrintln("- bAnnotator:" + sAnnotator);
		debugPrintln("- bStartTime:" + iStartTime);  
		debugPrintln("- iSampleFrequency:" + iSampleFrequency);
		debugPrintln("- iRate:" + iRate);
		debugPrintln("- iDuration:" + iDuration); 
		debugPrintln("- iSamples:" + iSamples); 
		debugPrintln("- bOutlier:" + bOutlier); 
		debugPrintln("- iSmoothing:" + iSmoothing);
		debugPrintln("- iEndTime:" + iEndTime);  
		debugPrintln("- bSampleNumber:" + bSampleNumber);
		debugPrintln("- bOutputSeconds1:" + bOutputSeconds1);
		debugPrintln("- bOutputMinutes:" + bOutputMinutes);	
		debugPrintln("- bOutputHours:" + bOutputHours);	
		debugPrintln("- sOutputName:" + sOutputName);
		
		try {
		
		String[] asEnvVar = new String[0];  
		
		// build command string
		int iIndexPeriod = sInputFile.lastIndexOf(".");
		String sRecord = sInputFile.substring(0, iIndexPeriod);
		
		//sOutputFile = sRecord;
		
		String sCommand = "tach -r " + sRecord; // record name
		sCommand += " -a " + sAnnotator;
		if(iStartTime > 0) sCommand += " -f " + iStartTime;
		if( (iSampleFrequency != 2) && (iSampleFrequency > 0) ) {
			sCommand += " -F " + iSampleFrequency;	
		}
		if( (iRate != 2) && (iRate > 0) ) sCommand += " -i " + iRate;
		if(iDuration > 0) sCommand += "-l " + iDuration;
		
		if(iSamples > 0) sCommand += " -n " + iSamples;
		
		// the -o is a required parameter, the default is the input filename.
		if(sOutputName.equals("")){
			sOutputName = sRecord;
		}
		
		sCommand += " -o " + sOutputName + "_tach";
		
		if(bOutlier) sCommand += " -O";
			
		if(iSmoothing > 1) sCommand += " -s " + iSmoothing; 
		if(iEndTime > 0) sCommand += " -t " + iEndTime;
		if(bSampleNumber) sCommand += " -v";
		if(bOutputSeconds1) sCommand += " -Vs";
		if(bOutputMinutes) sCommand += " -Vm";
		if(bOutputHours) sCommand += " -Vh";
		
		bRet = executeCommand(sCommand, asEnvVar, sPath);
		
		if(bRet){
			//set first output file to output generated by the sigamp command
			outputFilenames = new String[2];
			debugPrintln("- sOutputName:" + sOutputName);
			outputFilenames[0] = sPath + "/" + sOutputName + ".dat";
			outputFilenames[1] = sPath + "/" + sOutputName + ".hea";
		}else{
			debugPrintln("- Encountered errors.");
		}			
		
		} catch (Exception e) {
			bRet = false;
			e.printStackTrace();
		}
		
		return bRet;
	}	

	/** Runs the Physionet wrsamp tool to take in text input and convert it into a WFDB record.
	 * 
     * wrsamp reads text-format input and writes the specified columns in WFDB signal file format 16 (see signal(5) ), either to the standard output or to a disk file (see the -o option below). 
     * If no columns are specified, all columns are written (but see the -z option below).
     * Normally, wrsamp's input is line- and column-oriented, with line separator characters (usually ASCII linefeeds) separating input lines, and field separator characters (usually tabs, spaces, or commas) separating columns within each line. 
     * Columns need not be of constant width; the only requirement is that one or more field separator characters appear between adjacent columns. 
     * The output of rdsamp(1) is an example of an acceptable input format, as is CSV (comma-separated value) format.  
     * If the first input line contains any alphabetic character, it is assumed to contain signal names (column headings), and these are copied to the output header file (see the -o option below). 
     * In this case, if the second input line also contains any alphabetic character, it is assumed to contain unit names (i.e., the names of the physical units of each signal), and these are also copied to the output header file. 
     * Spaces embedded within unit names are written as underscores in the header file.
     * Lines are identified by line number. The first line of input not containing any alphabetic character is line 0. Similarly, columns are identified by column number, and the leftmost column is column 0. 
     * Columns may be selected in any order, and any given column may be selected more than once, or omitted. The order of column arguments determines the order of the signals in the output (data from the first column specified are written as signal 0, etc.) 
     * If an entry in a specified column is "-" (i.e., flagged as missing or invalid), or if an entry in a specified column is any other non-numeric value, wrsamp records it as an invalid sample in its output.
     * If line 0 appears to begin with a timestamp (a field of the form [hh:mm:ss.sss dd/mm/yyyy]), wrsamp records it as the base time (starting time) in the output header file. 
	 * 
	 * @param sInputFile - file name of the text file signal file to analyze.
	 * @param sPath - Produce output in CSV (comma-separated value) format (default: write output in tab-separated columns).
	 * @param sAnnotator - Check that each input line contains the same number of fields. (This test is normally disabled, to allow for input files containing preambles, trailers, or occasional extra fields not intended to be read as samples.)  
	 * @param iStartTime - Dither the input before converting it to integer output, by adding a random value to each sample. The random values are selected from a triangular probability density function between -1 and +1. Dithering is appropriate whenever the output has a lower resolution than the input. Note that the RNG used to generate the pseudo-random values is started with a fixed seed, so that wrsamp�s output is strictly reproducible. 
	 *                  Change the seed in the source and recompile to obtain a different realization of dither if desired.  
	 * @param bSummary - Specify the sampling frequency (in samples per second per signal) for the output signals (default: 250). This option is useful only in conjunction with -o, since it affects the output header file only. 
	 *                           This option has no effect on the output signal file, which contains one sample per signal for each line of input. 
	 *                           If you wish to change the sampling frequency in the signal file, see xform(1) . 
	 * @param iRate - Specify the gain (in A/D units per millivolt) for the output signals (default: 200). 
	 *                   To specify different gains for each output signal, provide a quoted list of values in place of n (see the examples below). 
	 *                   This option is useful only in conjunction with -o, since it affects the output header file only. 
	 *                   This option has no effect on the output signal file. If you wish to rescale samples in the signal file, use -x.  
	 * @param iEndTime - Print column headings (signal names on the first line, units on the second). 
	 * 						 The names of some signals are too wide to fit in the columns; such names are shortened by omitting the initial characters 
	 * 						 (since names of related signals often differ only at the end, this helps to make the columns identifiable). 
	 * 						 Names of units are shortened when necessary by omitting the final characters, since the initial characters are usually most important for distinguishing different units.      
	 * @param sOutputFile
	 * 
	 * Note:  The input file from the -i is not necessary.  The default input is from the stdin.  
	 *        Also, since input and output files are passed in from the web service, this function will be reworked to take those values in as parameters instead of in the form the
	 *        man page uses.  The command string will be built here.
	 *        Also note that we will need to create canned data for now until we get version 2 of the rdsamp function working (or the file output from version 1). 

	 * 
	 * @return
	 */	
	public boolean nguess(String sInputFile, String sPath, 
			String sAnnotator, int iStartTime, double dQInterval, int iEndTime, String sOutputName){
		boolean bRet = true;
		debugPrintln("nguess()");
		debugPrintln("- sInputFile:" + sInputFile);
		debugPrintln("- sPath:" + sPath);
		debugPrintln("- bAnnotator:" + sAnnotator);
		debugPrintln("- bStartTime:" + iStartTime);  		
		debugPrintln("- dQInterval:" + dQInterval);
		debugPrintln("- iRate:" + iEndTime);
		debugPrintln("- sOutputName:" + sOutputName);
		
		try {
		
		String[] asEnvVar = new String[0];  
		
		// build command string
		int iIndexPeriod = sInputFile.lastIndexOf(".");
		String sRecord = sInputFile.substring(0, iIndexPeriod);
		
		//sOutputFile = sRecord;
		
		String sCommand = "nguess -r " + sRecord; // record name
		sCommand += " -a " + sAnnotator;
		if(iStartTime > 0) sCommand += " -f " + iStartTime;

		if(dQInterval > 0) {
			sCommand += " -m " + dQInterval;	
		}

		
		if(!sOutputName.equals(""))
		{
			sCommand += " -o " + sOutputName;
		}
		else
		{
			sOutputName = "nguess";
		}
		
		if(iEndTime > 0) sCommand += " -t " + iEndTime;
		
		bRet = executeCommand(sCommand, asEnvVar, sPath);
		
		if(bRet){
			//set first output file to output generated by the sigamp command
			outputFilenames = new String[1];
			debugPrintln("- sOutputName:" + sOutputName);
			outputFilenames[0] = sPath + sRecord + "." + sOutputName;
		}else{
			debugPrintln("- Encountered errors.");
		}			
		
		} catch (Exception e) {
			bRet = false;
			e.printStackTrace();
		}
		
		return bRet;
	}
	
	/** Runs the Physionet ann2rr tool to take in text input and convert it into a WFDB record.
	 *  This converts annotation files to interval lists.
	 *  
	 * @param sInputFile - file name of the text file signal file to analyze.
	 * @param sPath - Produce output in CSV (comma-separated value) format (default: write output in tab-separated columns).
	 * @param bAllIntervals -A Print all intervals between annotations. 
	 * @param bConsecutive -c Print intervals between consecutive valid annotations only.
	 * @param iStartTime -f Begin at the specified time. 
	 * @param sIntervalFormat -i Print intervals in the specified format. 
	 * @param sMneumonicsEnd -p type [ type ... ] Print intervals ended by annotations of the specified types only.
	 * @param sMneumonicsBegin -P type [ type ... ] Print intervals begun by annotations of the specified types only. 
	 * @param iEndTime -t Stop at the specified time.     
	 * @param sFinalTimesFormat -v format Print final times in the specified format.
	 * @param sInitialTimesFormat -V format  Print initial times in the specified format.
	 * @param bFinalAnnotations -w Print final annotations.
	 * @param bInitialAnnotations -W Print initial annotations.
	 * @param sOutputName - Desired name of the output file, the extension ".rr" will be appended.
	 * 
	 * @return
	 */	
	public boolean ann2rr(String sInputFile, String sPath, 
			boolean bAllIntervals, boolean bConsecutive, int iStartTime, 
			String sIntervalFormat, String sMneumonicsEnd, String sMneumonicsBegin, int iEndTime, String sFinalTimesFormat, 
			String sInitialTimesFormat, boolean bFinalAnnotations, boolean bInitialAnnotations, String sOutputName){
		boolean bRet = true;
		debugPrintln("ann2rr()");
		debugPrintln("- sInputFile:" + sInputFile);
		debugPrintln("- sPath:" + sPath);
		debugPrintln("- bAllInverals:" + bAllIntervals);
		debugPrintln("- bConsecutive:" + bConsecutive);
		debugPrintln("- bStartTime:" + iStartTime);  		
		debugPrintln("- sIntervalFormat:" + sIntervalFormat);
		debugPrintln("- sMneumonicsEnd:" + sMneumonicsEnd);
		debugPrintln("- sMneumonicsBegin:" + sMneumonicsBegin);
		debugPrintln("- iEndTime:" + iEndTime);
		debugPrintln("- sFinalTimesFormat:" + sFinalTimesFormat);
		debugPrintln("- sInitialTimesFormat:" + sInitialTimesFormat);
		debugPrintln("- bFinalAnnotations:" + bFinalAnnotations);
		debugPrintln("- bInitialAnnotations:" + bInitialAnnotations);
		debugPrintln("- sOutputName:" + sOutputName);

		try {

			String[] asEnvVar = new String[0];  

			// build command string
			int iIndexPeriod = sInputFile.lastIndexOf(".");
			String sRecord = sInputFile.substring(0, iIndexPeriod);

			String sCommand = "ann2rr -r " + sRecord + " -a atr"; // record name

			if (bAllIntervals) {
				sCommand += " -A"; // Print all intervals between annotations. This option overrides the -c and -p options. 
			} else {
				if (bConsecutive) {
					sCommand += " -c"; // Print intervals between consecutive valid annotations only.
				}

				if (sMneumonicsEnd != null) {
					sCommand += " -p " + sMneumonicsEnd;
				}
			}

			if(iStartTime > 0) sCommand += " -f " + iStartTime;

			if(!sIntervalFormat.equals("")){
				sCommand += " -i " + sIntervalFormat;
			}

			if(!sMneumonicsBegin.equals("")){
				sCommand += " -P " + sMneumonicsBegin;
			}

			if(iEndTime > 0){ 
				sCommand += " -t " + iEndTime;
			}

			if(!sFinalTimesFormat.equals("")){
				sCommand += " -v " + sFinalTimesFormat;
			}

			if(!sInitialTimesFormat.equals("")){
				sCommand += " -V " + sInitialTimesFormat;
			}

			if(bFinalAnnotations){
				sCommand += " -w";
			}

			if(bInitialAnnotations){
				sCommand += " -W";
			}

			bRet = executeCommand(sCommand, asEnvVar, sPath);

			stdReturnHandler(sPath + sOutputName + ".rr");

			if(bRet){
				//set first output file.
				outputFilenames = new String[1];
				debugPrintln("- sOutputName:" + sOutputName);
				outputFilenames[0] = sPath + sOutputName + ".rr";
			}else{
				debugPrintln("- Encountered errors.");
			}			

		} catch (Exception e) {
			bRet = false;
			e.printStackTrace();
		}

		return bRet;
	}
	
		/** Runs the Physionet pnnlist tool to derive pNNx statistics from an annotation interval list or an annotation file .
		 * 
		 */
		public boolean pnnlist(String sInputFile, String sPath, int iStartTime, int iEndTime,
			String sAnnotator, double iInc, boolean bPercents, boolean bSeparateDistributions, String sOutputName){
		boolean bRet = true;
		debugPrintln("pnnlist()");
		debugPrintln("- sInputFile:" + sInputFile);
		debugPrintln("- sPath:" + sPath);
		debugPrintln("- bAnnotator:" + sAnnotator);
		debugPrintln("- iInc:" + iInc);  		
		debugPrintln("- dQInterval:" + bPercents);
		debugPrintln("- iRate:" + bSeparateDistributions);
		debugPrintln("- sOutputName:" + sOutputName);
		
		try {
		
		String[] asEnvVar = new String[0];  
		
		// build command string
		int iIndexPeriod = sInputFile.lastIndexOf(".");
		String sRecord = sInputFile.substring(0, iIndexPeriod);
		
		//sOutputFile = sRecord;
		
		getDirs();
		
		String sCommand = "pnnlist";
		if(iInc > 0) sCommand += " -i " + iInc;
		if(bPercents) sCommand += " -p";	
		if(bSeparateDistributions) sCommand += " -s";
		
		sCommand += " pNNx -r " + sRecord + " -a " + sAnnotator;
		if(iStartTime > 0) sCommand += " -f " + iStartTime;
		if(iEndTime > 0) sCommand += " -t " + iEndTime;
		debugPrintln("- sCommand:" + sCommand);
		
		boolean anotherBool = executeCommand("pwd", asEnvVar, "./");
		
		stdReturnHandler(sPath + sOutputName + ".pwd");
		
		bRet = executeCommand(sCommand, asEnvVar, sPath);
		
		bRet &= stdErrorHandler();
		
		stdReturnHandler(sPath + sOutputName + ".pnn");
		
		if(bRet){
			//set first output file to output generated by the sigamp command
			outputFilenames = new String[1];
			debugPrintln("- sOutputName:" + sOutputName);
			outputFilenames[0] = sPath + sOutputName + ".pnn";
		}else{
			debugPrintln("- Encountered errors.");
		}			
		
		} catch (Exception e) {
			bRet = false;
			e.printStackTrace();
		}
		
		return bRet;
	}
	
	/** Executes the command and pipes the response and errors to stdInputBuffer and stdError respectively.
	 * 
	 * @param sCommand - a specified system command.
	 * @param asEnvVar - array of strings, each element of which has environment variable settings in format name=value.
	 * @param sWorkingDir - the working directory of the subprocess, or null if the subprocess should inherit the working directory of the current process. 
	 * @return 
	 */
	private boolean executeCommand(String sCommand, String[] asEnvVar, String sWorkingDir){
		debugPrintln("++ executeCommand(" + sCommand );
		debugPrintln("++ , asEnvVar[" + asEnvVar.length + "]");
		debugPrintln("++, " + sWorkingDir + ")");
		boolean bRet = true;	
		
		try {
			File fWorkingDir = new File(sWorkingDir); //converts the dir name to File for exec command.
			Runtime rt = Runtime.getRuntime();
			Process process = rt.exec(sCommand, asEnvVar, fWorkingDir);
			InputStream is = process.getInputStream();  // The input stream for this method comes from the output from rt.exec()
			InputStreamReader isr = new InputStreamReader(is);
			stdInputBuffer = new BufferedReader(isr);
			
			InputStream errs = process.getErrorStream();
			InputStreamReader esr = new InputStreamReader(errs);
			stdError = new BufferedReader(esr);
		} catch (IOException ioe) {
			System.err.println("++ IOException Message: executeCommand(" + sCommand + ")" + ioe.getMessage());
			ioe.printStackTrace();
			bRet = false;
		} catch (Exception e) {
			System.err.println("++ Exception Message: executeCommand(" + sCommand + ")" + e.getMessage());
			e.printStackTrace();
			bRet = false;
		}
		debugPrintln("++ returning: " + bRet);
		return bRet;
	}

	/** This writes the output to the standard output if verbose is true
	 * 
	 * @throws IOException
	 */	
	
	private void stdReturnHandler() throws IOException{
	    String line;
		
	    int lineNum = 0;
	    debugPrintln("Here is the returned text of the command (if any):");
	    while ((line = stdInputBuffer.readLine()) != null) {
	    	debugPrintln(lineNum + ")" + line);
	    	lineNum++;
	    }
	}
	
	/** This writes the output of the execution to a file instead of standard output
	 * 
	 * @param outputFilename
	 * @throws IOException
	 */
	private void stdReturnHandler(String outputFilename) throws IOException{
	    String line;

		try{
			// Create file 
			debugPrintln("stdReturnHandler(FName) Creating output file: " + outputFilename);
			FileWriter fstream = new FileWriter(outputFilename);
			BufferedWriter bwOut = new BufferedWriter(fstream);

			int lineNum = 0;
		    debugPrintln("Here is the returned text of the command (if any): \"");
		    while ((line = stdInputBuffer.readLine()) != null) {
		    	bwOut.write(line);
		    	bwOut.newLine();
		    	if (lineNum<10){
		    		debugPrintln(lineNum + ")" + line);
		    	}
		    	
		    	lineNum++;
		    }
		    debugPrintln(". . . ");
		    debugPrintln(lineNum + ")" + line);
	        debugPrintln("\"");
			bwOut.flush();
			//Close the output stream
			bwOut.close();
		}catch (Exception e){//Catch exception if any
		   System.err.println("Error: " + e.getMessage());
		}
	}

	
	/** This function prints messages resulting from runtime problems to the system standard error
	 * @return Boolean variable:  True if there are no errors, false if there are errors.
	 * 
	 * @throws IOException
	 */	
	private boolean stdErrorHandler() throws IOException{
		boolean bRet = true;
		String error;
	    int lineNum = 0;

	    // read any errors from the attempted command
	    debugPrintln("");
	    debugPrintln("Here is the standard error of the command (if any): \"");
        while ((error = stdError.readLine()) != null) {
            System.err.println(lineNum + ">" + error);
            lineNum++;

			bRet = false;
        }
        debugPrintln("\"");
		return bRet;

	}

	public String getOutputFilename1() {
		return outputFilename1;
	}

	public String getOutputFilename2() {
		return outputFilename2;
	}
	
	public String[] getOutputFilenames() {
		return outputFilenames;
	}
	
	public void setVerbose(boolean verbose) {
		this.verbose = verbose;
	}

	private void debugPrintln(String text){
		if(verbose)	System.out.println("- WFDBApplicationWrapper - " + text);
	}
	
    private void getDirs() {
        File dir1 = new File(".");
        File dir2 = new File("..");
        try {
            debugPrintln("Current dir : " + dir1.getCanonicalPath());
            debugPrintln("Parent  dir : " + dir2.getCanonicalPath());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}
