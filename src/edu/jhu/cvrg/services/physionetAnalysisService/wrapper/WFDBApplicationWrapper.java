package edu.jhu.cvrg.services.physionetAnalysisService.wrapper;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

import org.apache.log4j.Logger;

import edu.jhu.cvrg.waveform.service.ApplicationWrapper;
import edu.jhu.cvrg.waveform.service.ServiceUtils;

public class WFDBApplicationWrapper  extends ApplicationWrapper{
	
	private static final String WORKING_DIR = "/";
	private String jobId;

	public WFDBApplicationWrapper() {
		log = Logger.getLogger(WFDBApplicationWrapper.class);
		this.jobId = "";
	}
	
	public WFDBApplicationWrapper(String identifier) {
		this();
		
		if(identifier != null){
			this.jobId = identifier;	
		}else{
			this.jobId = "";
		}
		
	}
	
	/** Runs the sqrs single-channel QRS detector. 
	 * Returns a WFDB annotation file with .qrs extention,
	 * and a plain text, space delimited version of the annotations (generated by Physionet rdann function)
	 * 
	 * @param sHeaderFile - file name of the WFDB (.hea) header file of the record to analyze.
	 * @param sPath - FULL path of the header file.
	 * @param begin - Begin at the specified time in record (default: the beginning of record). 
	 * @param bHighrez - Read the signal files in high-resolution mode (default: standard mode). 
	 *                   These modes are identical for ordinary records. 
	 *                   For multifrequency records, the standard decimation of oversampled signals to 
	 *                   the frame rate is suppressed in high-resolution mode 
	 *                   (rather, all other signals are resampled at the highest sampling frequency). 
	 * @param threshold - Specify the detection threshold (default: 500 units); 
	 *                     use higher values to reduce false detections,
	 *                     or lower values to reduce the number of missed beats. 
	 * @param sSignal - Specify the signal (number or name) to be used for QRS detection (default: 0). 
	 * @param time - Process until the specified time in record (-1 to default, the end of the record).
	 * @param outputName 
	 * 
	 * @return
	 */
	public boolean sqrs(String sHeaderFile, String sPath, Integer begin, boolean bHighrez, Integer threshold, String sSignal, Integer time, boolean rename){
		boolean bRet = true;
		debugPrintln("sqrs()");
		debugPrintln("- sHeaderFile:" + sHeaderFile);
		debugPrintln("- sPath:" + sPath);
		debugPrintln("- iBegin:" + begin);
		debugPrintln("- bHighrez:" + bHighrez);
		debugPrintln("- iThreshold:" + threshold);
		debugPrintln("- sSignal:" + sSignal);
		debugPrintln("- iTime:" + time);
		try {
			
			// no environment variables are needed, 
			// this is a place keeper so that the three parameter version of
			// exec can be used to specify the working directory.
			String[] asEnvVar = new String[0];  
			
			// build command string
			int iIndexPeriod = sHeaderFile.lastIndexOf(".");
			String sRecord = sHeaderFile.substring(0, iIndexPeriod);
			
			String sCommand = "sqrs -r " + sPath + sRecord;
			if(begin != null){ 
				sCommand += " -f " + begin;
			}
			if(bHighrez){
				sCommand += " -H ";
			}
			if(threshold != null && threshold != 500){ 
				sCommand += " -m " + threshold;
			}
			if("0".equals(sSignal)){ 
				sCommand += " -s " + sSignal;
			}
			if(time != null && time != -1){
				sCommand += " -t " + time;
			}
	
			bRet = executeCommand(sCommand, asEnvVar, WORKING_DIR);
			
			bRet &= stdErrorHandler();
			
			File originFile = new File(sPath+sRecord+ ".qrs");
			bRet = originFile.exists();
			
			if(bRet){
				stdReturnHandler();
				
				if(rename){
					String finalName = sPath + sRecord + '_'+ jobId + ".qrs" ;
					originFile.renameTo(new File(finalName));
				}
				
				outputFilenames = new String[1];
				outputFilenames[0] = originFile.getAbsolutePath();
			}else{
				debugPrintln("- Encountered errors.");
			}
			
		} catch (IOException e) {
			bRet = false;
			log.error(e.getMessage());
		}

		return bRet;
	}

	/** Runs the wqrs single-channel QRS detector. 
	 * Returns a WFDB annotation file with .wqrs extention,
	 * and a plain text, space delimited version of the annotations (generated by Physionet rdann function)
	 * 
	 * @param sHeaderFile - file name of the WFDB (.hea) header file of the record to analyze.
	 * @param sPath - FULL path of the header file.
	 * @param iBegin - Begin at the specified time in record (default: the beginning of record). 
	 * @param bHighrez - Read the signal files in high-resolution mode (default: standard mode). 
	 *                   These modes are identical for ordinary records. 
	 *                   For multifrequency records, the standard decimation of oversampled signals to 
	 *                   the frame rate is suppressed in high-resolution mode 
	 *                   (rather, all other signals are resampled at the highest sampling frequency). 
	 * @param iThreshold - Specify the detection threshold (default: 500 units); 
	 *                     use higher values to reduce false detections,
	 *                     or lower values to reduce the number of missed beats. 
	 * @param sSignal - Specify the signal (number or name) to be used for QRS detection (default: 0). 
	 * @param iTime - Process until the specified time in record (-1 to default, the end of the record).
	 * @param rename 
	 * @param outputName 
	 * 
	 * @return
	 */
	public boolean wqrs(String sHeaderFile, String sPath, 
			boolean bDumpRaw, int iBegin, boolean bPrintHelp, boolean bHighrez, boolean bFindJPoints, int iThreshold, 
			int iPowerFreq, boolean bResample, String sSignal, int iTime, boolean bVerbose, boolean rename){
		boolean bRet = true;
		debugPrintln("wqrs()");
		debugPrintln("- sHeaderFile:" + sHeaderFile);
		debugPrintln("- sPath:" + sPath);
		debugPrintln("- iBegin:" + iBegin);
		debugPrintln("- bHighrez:" + bHighrez);
		debugPrintln("- iThreshold:" + iThreshold);
		debugPrintln("- sSignal:" + sSignal);
		debugPrintln("- iTime:" + iTime);
		try {
			// no environment variables are needed, 
			// this is a place keeper so that the three parameter version of
			// exec can be used to specify the working directory.
			String[] asEnvVar = new String[0];  
			
			// build command string
			int iIndexPeriod = sHeaderFile.lastIndexOf(".");
			String sRecord = sHeaderFile.substring(0, iIndexPeriod);
			
			String sCommand = "wqrs -r " + sPath+ sRecord;
			if(bDumpRaw) sCommand   += " -d ";
			if(iBegin !=0) sCommand += " -f " + iBegin;
			if(bPrintHelp) sCommand += " -h ";
			if(bHighrez) sCommand   += " -H ";
			if(bFindJPoints) sCommand += " -j ";
			if(iThreshold != 500) sCommand += " -m " + iThreshold;
			if(iPowerFreq != 60) sCommand += " -p " + iPowerFreq;
			if(bResample) sCommand += " -R ";
			if(sSignal != null && sSignal.equals("0")) sCommand += " -s " + sSignal;
			if(iTime != -1) sCommand += " -t " + iTime;
			if(bVerbose) sCommand += " -v ";
	
			bRet = executeCommand(sCommand, asEnvVar, WORKING_DIR);
			
			bRet &= stdErrorHandler();
			
			
			if(bRet){
				stdReturnHandler();
				debugPrintln("-------------");
				outputFilenames = new String[1];
				//set first output file to the annotation (.wqrs) file generated by the sqrs command
				File originFile = new File(sPath+sRecord+ ".wqrs");
				
				if(rename){
					String finalName = sPath + sRecord + '_' + jobId + ".wqrs" ;
					originFile.renameTo(new File(finalName));
				}
				
				outputFilenames[0] = originFile.getAbsolutePath();
				
			}else{
				debugPrintln("- Encountered errors.");
			}
			
		} catch (IOException e) {
			bRet = false;
			log.error(e.getMessage());
		}

		return bRet;
	}


	
	/** Runs the sqrs single-channel QRS detector. 
	 * Returns a WFDB annotation file with .qrs extention,
	 * and a plain text, space delimited version of the annotations (generated by Physionet rdann function)
	 * 
	 * @param sHeaderFile - file name of the WFDB (.hea) header file of the record to analyze.
	 * @param sPath - FULL path of the header file.
	 * @param iBegin - Begin at the specified time in record (default: the beginning of record). 
	 * @param bHighrez - Read the signal files in high-resolution mode (default: standard mode). 
	 *                   These modes are identical for ordinary records. 
	 *                   For multifrequency records, the standard decimation of oversampled signals to 
	 *                   the frame rate is suppressed in high-resolution mode 
	 *                   (rather, all other signals are resampled at the highest sampling frequency). 
	 * @param iThreshold - Specify the detection threshold (default: 500 units); 
	 *                     use higher values to reduce false detections,
	 *                     or lower values to reduce the number of missed beats. 
	 * @param sSignal - Specify the signal (number or name) to be used for QRS detection (default: 0). 
	 * @param iTime - Process until the specified time in record (-1 to default, the end of the record).
	 * 
	 * @return
	 */
	public boolean ecgpuwave (String sHeaderFile, String sPath, int iBegin, String sInputAnnotator,
								int iBeatType, String sSignal, int iTime){
		boolean bRet = true;
		debugPrintln("ecgpuwave ()");
		debugPrintln("- sHeaderFile:" + sHeaderFile);
		debugPrintln("- sPath:" + sPath);
		debugPrintln("- iBegin:" + iBegin);
		debugPrintln("- sInputAnnotator:" + sInputAnnotator);
		debugPrintln("- iBeatType:" + iBeatType);
		debugPrintln("- sSignal:" + sSignal);
		debugPrintln("- iTime:" + iTime);
		try {
			
			// no environment variables are needed, 
			// this is a place keeper so that the three parameter version of
			// exec can be used to specify the working directory.
			String[] asEnvVar = new String[0];  
			
			// build command string
			int iIndexPeriod = sHeaderFile.lastIndexOf(".");
			String sRecord = sHeaderFile.substring(0, iIndexPeriod);
			
			String sCommand = "ecgpuwave -r " + sRecord;
			if(iBegin !=0) sCommand += " -f " + iBegin;
			if(!sInputAnnotator.equals("")){
				sCommand += " -i " + sInputAnnotator;
				// (must be used together with -i)
				if(iBeatType !=0) sCommand += " -n 1 "; 
			}
			if(!sSignal.equals("0")) sCommand += " -s " + sSignal;
			if(iTime != -1) sCommand += " -t " + iTime;
	
			bRet = executeCommand(sCommand, asEnvVar, sPath);
			stdReturnHandler();
			bRet &= stdErrorHandler();
			
			if(bRet){
				outputFilenames = new String[2];
				//set first output file to the annotation (.qrs) file generated by the sqrs command
				outputFilenames[0] = sPath + WORKING_DIR + sRecord + ".qrs";

				sCommand = "rdann -a qrs -r " + sRecord + " > " + sRecord + ".txt";
				bRet = executeCommand(sCommand, asEnvVar, sPath);
				stdReturnHandler();
				bRet &= stdErrorHandler();
				// set second output filename to the text file generated by rdann command.
				outputFilenames[1] = sPath + WORKING_DIR + sRecord + ".txt";
			}else{
				debugPrintln("- Encountered errors.");
			}
			
		} catch (IOException e) {
			bRet = false;
			log.error(e.getMessage());
		}

		return bRet;
	}

	

	/** Runs the Physionet sigamp tool to measure signal amplitudes of a WFDB record.  
	 * sigamp measures either baseline-corrected RMS amplitudes or (for suitably annotated ECG signals) 
	 * normal QRS peak-to-peak amplitudes for all signals of the specified record. 
	 * It makes up to 300 measurements (but see iNmax (-n) below) for each signal and calculates trimmed means 
	 * (by discarding the largest and smallest 5% of the measurements and taking the mean of the remaining 90%). 
	 * 
	 * @param sHeaderFile - file name of the WFDB (.hea) header file of the record to analyze.
	 * @param sPath - FULL path of the header file.
	 * @param iBegin - Begin at the specified time in record (default: the beginning of record). 
	 * @param sInputAnnotator - Measure QRS peak-to-peak amplitudes based on normal QRS annotations from the specified annotator. 
	 * @param dDeltaMeasureStart - Set the Beginning of measurement window in seconds before QRS annotations.
	 * @param dDeltaMeasureEnd -   Set the Ending of measurement window in seconds after QRS annotations.
	 * @param bHighrez - Read the signal files in high-resolution mode (default: standard mode). 
	 *                   These modes are identical for ordinary records. 
	 *                   For multifrequency records, the standard decimation of oversampled signals to 
	 *                   the frame rate is suppressed in high-resolution mode 
	 *                   (rather, all other signals are resampled at the highest sampling frequency). 
	 * @param iNmax - Make up to nmax measurements on each signal (default: 300). 
	 * @param iTime - Process until the specified time in record (-1 to default, the end of the record) Processing will be terminated prematurely if 250 measurements are made before reaching the specified time.
	 * @param fDeltaTimeWin- Set RMS amplitude measurement window in seconds. Default: dtw = 1 (second). 
	 * @param bVerbose - Verbose mode: return individual measurements as well as trimmed means. 
	 * @param bQuickmode - Quick mode: return individual measurements only. 
	 * @param bPrintPhysicalUnits - return results in physical units, time in seconds, same as -ps (default: ADC units)
	 * @param bPrintDay - return physical units + time of day and date if known
	 * @param bPrintElapsed - return physical units + elapsed time as <hours>:<minutes>:<seconds>
	 * @param bPrintHours - return physical units + elapsed time in hours
	 * @param bPrintMinutes - return physical units + elapsed time in minutes
	 * @param bPrintSeconds - return physical units + elapsed time in seconds (default)
	 * @param bPrintSamples - return physical units + elapsed time in sample intervals
	 * @param outputName 
	 * 
	 * @return
	 */
	public boolean sigamp(String sHeaderFile, String sPath, 
								int iBegin, String sInputAnnotator, double dDeltaMeasureStart, double dDeltaMeasureEnd, boolean bHighRez,
								int iNmax, int iTime, double dDeltaTimeWin,
								boolean bVerbose, boolean bQuickmode,
								boolean bPrintPhysicalUnits, boolean bPrintDay, boolean bPrintElapsed, 
								boolean bPrintHours, boolean bPrintMinutes, boolean bPrintSeconds, boolean bPrintSamples, String outputName){
		boolean bRet = true;
		debugPrintln("sigamp()");
		debugPrintln("- sHeaderFile:" + sHeaderFile);
		debugPrintln("- sPath:" + sPath);
		debugPrintln("- iBegin:" + iBegin);
		debugPrintln("- sInputAnnotator:" + sInputAnnotator); // Measure QRS peak-to-peak amplitudes based on normal QRS annotations from the specified annotator. 
		debugPrintln("- fdt1:" + dDeltaMeasureStart);
		debugPrintln("- fdt2:" + dDeltaMeasureEnd);
		debugPrintln("- bHighRez:" + bHighRez);
		debugPrintln("- iNmax:" + iNmax); // Make up to nmax measurements on each signal (default: 300). 
		debugPrintln("- iTime:" + iTime); // Process until the specified time in record (-1 to default, the end of the record) Processing will be terminated prematurely if 250 measurements are made before reaching the specified time.
		debugPrintln("- fDeltaTimeWin:" + dDeltaTimeWin); // Set RMS amplitude measurement window. Default: dtw = 1 (second). 
		//--  output adjustments
		debugPrintln("- bVerbose:" + bVerbose); // Verbose mode: print individual measurements as well as trimmed means. 
		debugPrintln("- bQuickmode:" + bQuickmode); // Quick mode: print individual measurements only. 
		debugPrintln("- bPrintPhysicalUnits:" + bPrintPhysicalUnits); //  print results in physical units, time in seconds, same as -ps (default: ADC units)
		debugPrintln("- bPrintDay:" + bPrintDay); // print physical units + time of day and date if known
		debugPrintln("- bPrintElapsed:" + bPrintElapsed); // print physical units + elapsed time as <hours>:<minutes>:<seconds>
		debugPrintln("- bPrintHours:" + bPrintHours);// print physical units + elapsed time in hours
		debugPrintln("- bPrintMinutes:" + bPrintMinutes); // print physical units + elapsed time in minutes
		debugPrintln("- bPrintSeconds:" + bPrintSeconds); // print physical units + elapsed time in seconds (default)
		debugPrintln("- bPrintSamples:" + bPrintSamples); // print physical units + elapsed time in sample intervals


		try {
			
			// no environment variables are needed, 
			// this is a place keeper so that the three parameter version of
			// exec can be used to specify the working directory.
			String[] asEnvVar = new String[0];  
			
			// build command string
			int iIndexPeriod = sHeaderFile.lastIndexOf(".");
			String sRecord = sHeaderFile.substring(0, iIndexPeriod);
			
			String sCommand = "sigamp -r " + sPath + sRecord; // record name (same as header file name.)
			if(iBegin != 0) sCommand += " -f " + iBegin;
			if(sInputAnnotator != null && !sInputAnnotator.equals("")){
				sCommand += " -a " + sInputAnnotator; // Measure QRS peak-to-peak amplitudes based on normal QRS annotations from the specified annotator. 
			}
			// ( -d option must be used with -a;)
			if((dDeltaMeasureStart != 0.05) || (dDeltaMeasureEnd != 0.05)) sCommand += " -a " + dDeltaMeasureStart + " " + dDeltaMeasureEnd; // Set the measurement window relative to QRS annotations. 
			if(bHighRez) sCommand += " -H "; // Read the signal files in high-resolution mode (default: standard mode).
			if(iNmax != 300) sCommand += " -n " + iNmax; // Make up to nmax measurements on each signal (default: 300).			
			if(iTime != -1) sCommand += " -t " + iTime; // Process until the specified time in record (default: the end of the record). Processing will be terminated prematurely if 250 measurements are made before reaching the specified time. 
			if(dDeltaTimeWin != 1.0) sCommand += " -w " + dDeltaTimeWin; //Set RMS amplitude measurement window in seconds. Default: dtw = 1 (second). 
			//--  output adjustments
			if(bVerbose) sCommand += " -v "; //Verbose mode: print individual measurements as well as trimmed means. 
			if(bQuickmode) sCommand += " -q "; // Quick mode: print individual measurements only, not trimmed means.
			if(bPrintPhysicalUnits) sCommand += " -p ";//  print results in physical units, time in seconds, same as -ps(default: ADC units)
			if(bPrintDay) sCommand += " -pd ";// print physical units + time of day and date if known
			if(bPrintElapsed) sCommand += " -pe ";//print physical units + elapsed time as <hours>:<minutes>:<seconds>
			if(bPrintHours) sCommand += " -ph ";// print physical units + elapsed time in hours
			if(bPrintMinutes) sCommand += " -pm ";//print physical units + elapsed time in minutes
			if(bPrintSeconds) sCommand += " -ps ";// print physical units + elapsed time in seconds (default, same as -p)
			if(bPrintSamples) sCommand += " -pS ";// print physical units + elapsed time in sample intervals

			bRet = executeCommand(sCommand, asEnvVar, WORKING_DIR);
			
			bRet &= stdErrorHandler();
			
			if(bRet){
				stdReturnHandler(sPath + outputName + ".txt");
				outputFilenames = new String[1];
				//set first output file to output generated by the sigamp command
				outputFilenames[0] = sPath + outputName + ".txt";
				
			}else{
				debugPrintln("- Encountered errors.");
			}
			
		} catch (IOException e) {
			bRet = false;
			log.error(e.getMessage());
		}

		return bRet;
	}

	/** Runs the Physionet rdsamp tool to read and display WFDB records.  
	 * rdsamp reads signal files for the specified record and writes the samples as decimal numbers on the standard output. 
	 * If no options are provided, rdsamp starts at the beginning of the record and prints all samples. 
	 * By default, each line of output contains the sample number and samples from each signal, 
	 * beginning with channel 0, separated by tabs. 
	 * 
	 * @param sHeaderFile - file name of the WFDB (.dat) signal file to analyze.
	 * @param sPath - Produce output in CSV (comma-separated value) format (default: write output in tab-separated columns).
	 * @param bCsv - Begin at the specified time in record (default: the beginning of record). 
	 * @param iStarttime - Begin at the specified time. By default, rdsamp starts at the beginning of the record.  
	 * @param bSummary - Set the Beginning of measurement window in seconds before QRS annotations.
	 * @param bHighrez - Read the signal files in high-resolution mode (default: standard mode). 
	 *                   These modes are identical for ordinary records. 
	 *                   For multifrequency records, the standard decimation of oversampled signals to 
	 *                   the frame rate is suppressed in high-resolution mode 
	 *                   (rather, all other signals are resampled at the highest sampling frequency). 
	 * @param dInterval - Limit the amount of output to the specified time interval 
	 * 					 (in standard time format; default: no limit). 
	 * 					 If both -l and -t are used, rdsamp stops at the earlier of the two limits. 
	 * @param bSeconds - Print times in seconds and milliseconds, and values in physical units. By default, rdsamp prints times in sample intervals and values in A/D units.
	 * @param bHighprecision - Same as -p, but yields higher precision in the sample values (8 decimal places rather than 3).
	 * 						   A single character can be attached to either -p or -P to choose the
	 * 						   format for the printed times in the first column of output. The choices are: 
	 * @param sSignallist - Print only the signals named in the signal-list (one or more input signal numbers or names, separated by spaces; 
	 * 						default: print all signals). This option may be used to re-order or duplicate signals. 
	 * @param sFirstsignal - Search for the first valid sample of the specified signal (a signal name or number) at or following the time specified with -f 
	 * 						 (or the beginning of the record if the -f option is not present), and begin printing at that time. 
	 * @param iEndtime - Process until the specified time in record (-1 to default, the end of the record) Processing will be terminated prematurely if 250 measurements are made before reaching the specified time. 
	 * @param bColumnheads - Print column headings (signal names on the first line, units on the second). 
	 * 						 The names of some signals are too wide to fit in the columns; such names are shortened by omitting the initial characters 
	 * 						 (since names of related signals often differ only at the end, this helps to make the columns identifiable). 
	 * 						 Names of units are shortened when necessary by omitting the final characters, since the initial characters are usually most important for distinguishing different units.  
	 * @param bXML - Produce output in WFDB-XML format (same as the CSV format produced using the -c option, but wrapped within an XML header and trailer). 
	 * 				 This format is recognized and parsed automatically by wrsamp. 
	 * @param outputName 
	 * @param sOutputFile

	 * 
	 * @return
	 */
	public boolean rdsamp(String sHeaderFile, String sPath, 
								boolean bCsv, int iStarttime, boolean bSummary, boolean bHighrez, double dInterval,
								String sFormatOutput, String sSignallist, String sFirstsignal,
								int iEndtime, boolean bColumnheads, boolean bXML, String outputName){
		boolean bRet = true;
		debugPrintln("rdsamp()");
		debugPrintln("- sHeaderFile: " + sHeaderFile);
		debugPrintln("- sPath: " + sPath);
		debugPrintln("- bCsv: " + bCsv);
		debugPrintln("- iStarttime: " + iStarttime);  
		debugPrintln("- bSummary: " + bSummary);
		debugPrintln("- bHighrez: " + bHighrez);
		debugPrintln("- dInterval: " + dInterval);
		debugPrintln("- sFormatOutput: " + sFormatOutput); 
		debugPrintln("- sSignallist: " + sSignallist); 
		debugPrintln("- sFirstSignal: " + sFirstsignal); 
		debugPrintln("- iEndtime: " + iEndtime);
		//--  output adjustments
		debugPrintln("- bColumnheads: " + bColumnheads);  
		debugPrintln("- bXML: " + bXML);  

		try {
		
			String[] asEnvVar = new String[0];  
			
			// build command string
			int iIndexPeriod = sHeaderFile.lastIndexOf(".");
			String sRecord = sHeaderFile.substring(0, iIndexPeriod);
			
			String sCommand = "rdsamp -r " + sPath + sRecord; // record name
			if(bCsv) sCommand += " -c"; // CSV Format
			if(iStarttime > 0) sCommand += " -f " + iStarttime;
			if(bSummary) sCommand += " -h";	
			if(bHighrez) sCommand += " -H";
			if(dInterval > 0) sCommand += " -c " + dInterval;
			
			// one of the following: pd, pe, ph, pm, ps, pS, Pd, Pe, Ph, Pm, Ps, PS
			if(sFormatOutput != null && !sFormatOutput.equals("")) sCommand += " -" + sFormatOutput; 
			
			if(sSignallist !=null && !sSignallist.equals("")) sCommand += " -s " + sSignallist;
			if(sFirstsignal != null && !sFirstsignal.equals("")) sCommand += " -S " + sFirstsignal;
			if(iEndtime > 0) sCommand += " -t " + iEndtime;
			if(bColumnheads) sCommand += " -v";
			if(bXML) sCommand += " -X"; //Produce output in WFDB-XML format 

			if (bCsv)
			{
				outputName += ".csv";
			}
			else if (bXML)
			{
				outputName += ".xml";
			}
			else
			{
				outputName += ".txt";
			}			
			debugPrintln("- sOutputFile: " + outputName);  

			// essentially, we will be trying to stream the data and write it line by line to the output file as we receive it
			
			bRet = executeCommand(sCommand, asEnvVar, WORKING_DIR);			
			
			stdReturnHandler(sPath + outputName);
			
			bRet &= stdErrorHandler();
			
			if(bRet){
				//set first output file to output generated by the sigamp command
				outputFilenames = new String[1];
				outputFilenames[0] = sPath + outputName;
			}else{
				debugPrintln("- Encountered errors.");
			}			
			
		} catch (IOException e) {
			bRet = false;
			log.error(e.getMessage());
		}

		return bRet;
	}
	
	/** Runs the Physionet wrsamp tool to take in text input and convert it into a WFDB record.
	 * 
     * wrsamp reads text-format input and writes the specified columns in WFDB signal file format 16 (see signal(5) ), either to the standard output or to a disk file (see the -o option below). 
     * If no columns are specified, all columns are written (but see the -z option below).
     * Normally, wrsamp's input is line- and column-oriented, with line separator characters (usually ASCII linefeeds) separating input lines, and field separator characters (usually tabs, spaces, or commas) separating columns within each line. 
     * Columns need not be of constant width; the only requirement is that one or more field separator characters appear between adjacent columns. 
     * The output of rdsamp(1) is an example of an acceptable input format, as is CSV (comma-separated value) format.  
     * If the first input line contains any alphabetic character, it is assumed to contain signal names (column headings), and these are copied to the output header file (see the -o option below). 
     * In this case, if the second input line also contains any alphabetic character, it is assumed to contain unit names (i.e., the names of the physical units of each signal), and these are also copied to the output header file. 
     * Spaces embedded within unit names are written as underscores in the header file.
     * Lines are identified by line number. The first line of input not containing any alphabetic character is line 0. Similarly, columns are identified by column number, and the leftmost column is column 0. 
     * Columns may be selected in any order, and any given column may be selected more than once, or omitted. The order of column arguments determines the order of the signals in the output (data from the first column specified are written as signal 0, etc.) 
     * If an entry in a specified column is "-" (i.e., flagged as missing or invalid), or if an entry in a specified column is any other non-numeric value, wrsamp records it as an invalid sample in its output.
     * If line 0 appears to begin with a timestamp (a field of the form [hh:mm:ss.sss dd/mm/yyyy]), wrsamp records it as the base time (starting time) in the output header file. 
	 * 
	 * @param sInputFile - file name of the text file signal file to analyze.
	 * @param sPath - Produce output in CSV (comma-separated value) format (default: write output in tab-separated columns).
	 * @param bCheckInput - Check that each input line contains the same number of fields. (This test is normally disabled, to allow for input files containing preambles, trailers, or occasional extra fields not intended to be read as samples.)  
	 * @param bDither - Dither the input before converting it to integer output, by adding a random value to each sample. The random values are selected from a triangular probability density function between -1 and +1. Dithering is appropriate whenever the output has a lower resolution than the input. Note that the RNG used to generate the pseudo-random values is started with a fixed seed, so that wrsamp�s output is strictly reproducible. 
	 *                  Change the seed in the source and recompile to obtain a different realization of dither if desired.  
	 * @param iCopyStart - Start copying with line n. By default, wrsamp starts at the beginning of its standard input (line 0).
	 * @param iSampleFrequency - Specify the sampling frequency (in samples per second per signal) for the output signals (default: 250). This option is useful only in conjunction with -o, since it affects the output header file only. 
	 *                           This option has no effect on the output signal file, which contains one sample per signal for each line of input. 
	 *                           If you wish to change the sampling frequency in the signal file, see xform(1) . 
	 * @param bSummary - Specify the gain (in A/D units per millivolt) for the output signals (default: 200). 
	 *                   To specify different gains for each output signal, provide a quoted list of values in place of n (see the examples below). 
	 *                   This option is useful only in conjunction with -o, since it affects the output header file only. 
	 *                   This option has no effect on the output signal file. If you wish to rescale samples in the signal file, use -x.  
	 * @param iCharacters - Same as -p, but yields higher precision in the sample values (8 decimal places rather than 3).
	 * 						   A single character can be attached to either -p or -P to choose the
	 * 						   format for the printed times in the first column of output. The choices are: 
	 * @param sRecordName - Print only the signals named in the signal-list (one or more input signal numbers or names, separated by spaces; 
	 * 						default: print all signals). This option may be used to re-order or duplicate signals. 
	 * @param sFormat - Search for the first valid sample of the specified signal (a signal name or number) at or following the time specified with -f 
	 * 						 (or the beginning of the record if the -f option is not present), and begin printing at that time. 
	 * @param cLineSeparator - Process until the specified time in record (-1 to default, the end of the record) Processing will be terminated prematurely if 250 measurements are made before reaching the specified time. 
	 * @param cFieldSeparator - Print column headings (signal names on the first line, units on the second). 
	 * 						 The names of some signals are too wide to fit in the columns; such names are shortened by omitting the initial characters 
	 * 						 (since names of related signals often differ only at the end, this helps to make the columns identifiable). 
	 * 						 Names of units are shortened when necessary by omitting the final characters, since the initial characters are usually most important for distinguishing different units.  
	 * @param iLineStop - Produce output in WFDB-XML format (same as the CSV format produced using the -c option, but wrapped within an XML header and trailer). 
	 * 				 This format is recognized and parsed automatically by wrsamp. 
	 * @param dMultiply - Produce output in WFDB-XML format (same as the CSV format produced using the -c option, but wrapped within an XML header and trailer).
	 * @param bNoZero - Produce output in WFDB-XML format (same as the CSV format produced using the -c option, but wrapped within an XML header and trailer).    
	 * @param sOutputFile
	 * 
	 * Note:  The input file from the -i is not necessary.  The default input is from the stdin.  
	 *        Also, since input and output files are passed in from the web service, this function will be reworked to take those values in as parameters instead of in the form the
	 *        man page uses.  The command string will be built here.
	 *        Also note that we will need to create canned data for now until we get version 2 of the rdsamp function working (or the file output from version 1). 

	 * 
	 * @return
	 */
	public boolean wrsamp(String sInputFile, String sPath, 
								boolean bCheckInput, boolean bDither, int iCopyStart, int iSampleFrequency,
								int iCharacters, String sRecordName, String sFormat,
								char cLineSeparator, char cFieldSeparator, int iLineStop, double dMultiply, boolean bNoZero, String sOutputName){
		boolean bRet = true;
		debugPrintln("wrsamp()");
		debugPrintln("- sInputFile:" + sInputFile);
		debugPrintln("- sPath:" + sPath);
		debugPrintln("- bCheckInput:" + bCheckInput);
		debugPrintln("- bDither:" + bDither);  
		debugPrintln("- iCopyStart:" + iCopyStart);
		debugPrintln("- iSampleFrequency:" + iSampleFrequency);
		debugPrintln("- iCharacters:" + iCharacters); 
		debugPrintln("- sRecordName:" + sRecordName); 
		debugPrintln("- sFormat:" + sFormat); 
		debugPrintln("- cLineSeparator:" + cLineSeparator);
		debugPrintln("- cFieldSeparator:" + cFieldSeparator);  
		debugPrintln("- iLineStop:" + iLineStop);
		debugPrintln("- dMultiply:" + dMultiply);
		debugPrintln("- bNoZero:" + bNoZero);		
		debugPrintln("- sOutputName:" + sOutputName);

		try {
		
			String[] asEnvVar = new String[0];  
			
			// build command string
			
			//sOutputFile = sRecord;
			
			String sCommand = "wrsamp -i " + sPath + sInputFile; // record name
			if(bCheckInput) sCommand += " -c";
			if(bDither) sCommand += " -d ";
			if(iCopyStart > 0 ) sCommand += " -f " + iCopyStart;	
			if(iSampleFrequency > 0) sCommand += " -F " + iSampleFrequency;
			if(iCharacters > 0) sCommand += " -l " + iCharacters;
			if(dMultiply > 0) sCommand += " -x " + dMultiply;
			
			// the -o is a required parameter, the default is the input filename.
			if(sOutputName.equals(""))
			{
				int iIndexPeriod = sInputFile.lastIndexOf(".");
				sOutputName = sInputFile.substring(0, iIndexPeriod);
			}
			
			sCommand += " -o " + sPath + sOutputName;
						
			if(cLineSeparator != '\u0000') sCommand += " -r " + cLineSeparator; // \u0000 is the empty char.  It is used since an empty char of '' cannot be declared in Java
			if(cFieldSeparator != '\u0000') sCommand += " -s " + cFieldSeparator;
			if(iLineStop > 0) sCommand += " -t " + iLineStop;
			if(bNoZero) sCommand += " -z";

			// essentially, we will be trying to stream the data and write it line by line to the output file as we receive it
			
			bRet = executeCommand(sCommand, asEnvVar, WORKING_DIR);			

			bRet &= stdErrorHandler();
			
			if(bRet){
				//set first output file to output generated by the sigamp command
				outputFilenames = new String[2];
				outputFilenames[0] = sPath + sOutputName + ".dat";
				outputFilenames[1] = sPath + sOutputName + ".hea";
			}else{
				debugPrintln("- Encountered errors.");
			}			
			
		} catch (Exception e) {
			bRet = false;
			log.error(e.getMessage());
		}

		return bRet;
	}	

	/** Runs the Physionet wrsamp tool to take in text input and convert it into a WFDB record.
	 * 
     * wrsamp reads text-format input and writes the specified columns in WFDB signal file format 16 (see signal(5) ), either to the standard output or to a disk file (see the -o option below). 
     * If no columns are specified, all columns are written (but see the -z option below).
     * Normally, wrsamp's input is line- and column-oriented, with line separator characters (usually ASCII linefeeds) separating input lines, and field separator characters (usually tabs, spaces, or commas) separating columns within each line. 
     * Columns need not be of constant width; the only requirement is that one or more field separator characters appear between adjacent columns. 
     * The output of rdsamp(1) is an example of an acceptable input format, as is CSV (comma-separated value) format.  
     * If the first input line contains any alphabetic character, it is assumed to contain signal names (column headings), and these are copied to the output header file (see the -o option below). 
     * In this case, if the second input line also contains any alphabetic character, it is assumed to contain unit names (i.e., the names of the physical units of each signal), and these are also copied to the output header file. 
     * Spaces embedded within unit names are written as underscores in the header file.
     * Lines are identified by line number. The first line of input not containing any alphabetic character is line 0. Similarly, columns are identified by column number, and the leftmost column is column 0. 
     * Columns may be selected in any order, and any given column may be selected more than once, or omitted. The order of column arguments determines the order of the signals in the output (data from the first column specified are written as signal 0, etc.) 
     * If an entry in a specified column is "-" (i.e., flagged as missing or invalid), or if an entry in a specified column is any other non-numeric value, wrsamp records it as an invalid sample in its output.
     * If line 0 appears to begin with a timestamp (a field of the form [hh:mm:ss.sss dd/mm/yyyy]), wrsamp records it as the base time (starting time) in the output header file. 
	 * 
	 * @param sInputFile - file name of the text file signal file to analyze.
	 * @param sPath - Produce output in CSV (comma-separated value) format (default: write output in tab-separated columns).
	 * @param sAnnotator - Check that each input line contains the same number of fields. (This test is normally disabled, to allow for input files containing preambles, trailers, or occasional extra fields not intended to be read as samples.)  
	 * @param iStartTime - Dither the input before converting it to integer output, by adding a random value to each sample. The random values are selected from a triangular probability density function between -1 and +1. Dithering is appropriate whenever the output has a lower resolution than the input. Note that the RNG used to generate the pseudo-random values is started with a fixed seed, so that wrsamp�s output is strictly reproducible. 
	 *                  Change the seed in the source and recompile to obtain a different realization of dither if desired.  
	 * @param iSampleFrequency - Start copying with line n. By default, wrsamp starts at the beginning of its standard input (line 0).
	 * @param bSummary - Specify the sampling frequency (in samples per second per signal) for the output signals (default: 250). This option is useful only in conjunction with -o, since it affects the output header file only. 
	 *                           This option has no effect on the output signal file, which contains one sample per signal for each line of input. 
	 *                           If you wish to change the sampling frequency in the signal file, see xform(1) . 
	 * @param iRate - Specify the gain (in A/D units per millivolt) for the output signals (default: 200). 
	 *                   To specify different gains for each output signal, provide a quoted list of values in place of n (see the examples below). 
	 *                   This option is useful only in conjunction with -o, since it affects the output header file only. 
	 *                   This option has no effect on the output signal file. If you wish to rescale samples in the signal file, use -x.  
	 * @param iDuration - Same as -p, but yields higher precision in the sample values (8 decimal places rather than 3).
	 * 						   A single character can be attached to either -p or -P to choose the
	 * 						   format for the printed times in the first column of output. The choices are: 
	 * @param iSamples - Print only the signals named in the signal-list (one or more input signal numbers or names, separated by spaces; 
	 * 						default: print all signals). This option may be used to re-order or duplicate signals. 
	 * @param bOutlier - Search for the first valid sample of the specified signal (a signal name or number) at or following the time specified with -f 
	 * 						 (or the beginning of the record if the -f option is not present), and begin printing at that time. 
	 * @param iSmoothing - Process until the specified time in record (-1 to default, the end of the record) Processing will be terminated prematurely if 250 measurements are made before reaching the specified time. 
	 * @param iEndTime - Print column headings (signal names on the first line, units on the second). 
	 * 						 The names of some signals are too wide to fit in the columns; such names are shortened by omitting the initial characters 
	 * 						 (since names of related signals often differ only at the end, this helps to make the columns identifiable). 
	 * 						 Names of units are shortened when necessary by omitting the final characters, since the initial characters are usually most important for distinguishing different units.  
	 * @param bSampleNumber - Produce output in WFDB-XML format (same as the CSV format produced using the -c option, but wrapped within an XML header and trailer). 
	 * 				 This format is recognized and parsed automatically by wrsamp. 
	 * @param bOutputSeconds1 - Produce output in WFDB-XML format (same as the CSV format produced using the -c option, but wrapped within an XML header and trailer).
	 * @param bOutputSeconds2 - Produce output in WFDB-XML format (same as the CSV format produced using the -c option, but wrapped within an XML header and trailer).    
	 * @param sOutputFile
	 * 
	 * Note:  The input file from the -i is not necessary.  The default input is from the stdin.  
	 *        Also, since input and output files are passed in from the web service, this function will be reworked to take those values in as parameters instead of in the form the
	 *        man page uses.  The command string will be built here.
	 *        Also note that we will need to create canned data for now until we get version 2 of the rdsamp function working (or the file output from version 1). 

	 * 
	 * @return
	 */
	public boolean tach(String sInputFile, String sPath, 
			String sAnnotator, int iStartTime, int iSampleFrequency, int iRate,
			int iDuration, int iSamples, boolean bOutlier,
			int iSmoothing, int iEndTime, boolean bSampleNumber, boolean bOutputSeconds1, boolean bOutputMinutes, boolean bOutputHours, String sOutputName){
		boolean bRet = true;
		debugPrintln("tach()");
		debugPrintln("- sInputFile:" + sInputFile);
		debugPrintln("- sPath:" + sPath);
		debugPrintln("- bAnnotator:" + sAnnotator);
		debugPrintln("- bStartTime:" + iStartTime);  
		debugPrintln("- iSampleFrequency:" + iSampleFrequency);
		debugPrintln("- iRate:" + iRate);
		debugPrintln("- iDuration:" + iDuration); 
		debugPrintln("- iSamples:" + iSamples); 
		debugPrintln("- bOutlier:" + bOutlier); 
		debugPrintln("- iSmoothing:" + iSmoothing);
		debugPrintln("- iEndTime:" + iEndTime);  
		debugPrintln("- bSampleNumber:" + bSampleNumber);
		debugPrintln("- bOutputSeconds1:" + bOutputSeconds1);
		debugPrintln("- bOutputMinutes:" + bOutputMinutes);	
		debugPrintln("- bOutputHours:" + bOutputHours);	
		debugPrintln("- sOutputName:" + sOutputName);
		
		try {
		
		String[] asEnvVar = new String[0];  
		
		// build command string
		int iIndexPeriod = sInputFile.lastIndexOf(".");
		String sRecord = sInputFile.substring(0, iIndexPeriod);
		
		//sOutputFile = sRecord;
		
		String sCommand = "tach -r " + sPath + sRecord; // record name
		
		sCommand += " -a " + sAnnotator;
		
		if(iStartTime > 0) sCommand += " -f " + iStartTime;
		if( (iSampleFrequency != 2) && (iSampleFrequency > 0) ) {
			sCommand += " -F " + iSampleFrequency;	
		}
		if( (iRate != 2) && (iRate > 0) ) sCommand += " -i " + iRate;
		if(iDuration > 0) sCommand += "-l " + iDuration;
		
		if(iSamples > 0) sCommand += " -n " + iSamples;
		
		// the -o is a required parameter, the default is the input filename.
		if(sOutputName.equals("")){
			sOutputName = sRecord;
		}
		
		//Problems with the output file path size, it's so big. 
		// (path + filename) must have 33 characters at maximum 
		String finalPathName = sPath + sOutputName;
		String tempName = RandomString.newString(5);
		String tempPathName = ServiceUtils.SERVER_TEMP_ANALYSIS_FOLDER + File.separator + tempName;
		
		sCommand += " -o " + tempPathName;
		
		if(bOutlier) sCommand += " -O";
			
		if(iSmoothing > 1) sCommand += " -s " + iSmoothing; 
		if(iEndTime > 0) sCommand += " -t " + iEndTime;
		if(bSampleNumber) sCommand += " -v";
		if(bOutputSeconds1) sCommand += " -Vs";
		if(bOutputMinutes) sCommand += " -Vm";
		if(bOutputHours) sCommand += " -Vh";
		
		bRet = executeCommand(sCommand, asEnvVar, WORKING_DIR);
		
		bRet &= stdErrorHandler();
		
		if(bRet){
			
			new File(tempPathName+".dat").renameTo(new File(finalPathName + ".dat"));
			
			File tmpHea = new File(tempPathName + ".hea");
			File finalHea = new File(finalPathName + ".hea");
			
			finalHea.createNewFile();
			
			BufferedReader reader = new BufferedReader(new FileReader(tmpHea));
			BufferedWriter writer = new BufferedWriter(new FileWriter(finalHea));
			
			String line;
			while ((line = reader.readLine()) != null) {
				line.replaceAll(tempPathName, finalPathName);
				writer.write(line);
				writer.newLine();
			}
			
			reader.close();
			writer.flush();
			writer.close();
			
			tmpHea.delete();
			RandomString.release(tempName);
			
			//set first output file to output generated by the sigamp command
			outputFilenames = new String[2];
			debugPrintln("- sOutputName:" + sOutputName);
			outputFilenames[0] = finalPathName + ".dat";
			outputFilenames[1] = finalPathName + ".hea";
		}else{
			debugPrintln("- Encountered errors.");
		}			
		
		} catch (Exception e) {
			bRet = false;
			log.error(e.getMessage());
		}
		
		return bRet;
	}	

	/** Runs the Physionet wrsamp tool to take in text input and convert it into a WFDB record.
	 * 
     * wrsamp reads text-format input and writes the specified columns in WFDB signal file format 16 (see signal(5) ), either to the standard output or to a disk file (see the -o option below). 
     * If no columns are specified, all columns are written (but see the -z option below).
     * Normally, wrsamp's input is line- and column-oriented, with line separator characters (usually ASCII linefeeds) separating input lines, and field separator characters (usually tabs, spaces, or commas) separating columns within each line. 
     * Columns need not be of constant width; the only requirement is that one or more field separator characters appear between adjacent columns. 
     * The output of rdsamp(1) is an example of an acceptable input format, as is CSV (comma-separated value) format.  
     * If the first input line contains any alphabetic character, it is assumed to contain signal names (column headings), and these are copied to the output header file (see the -o option below). 
     * In this case, if the second input line also contains any alphabetic character, it is assumed to contain unit names (i.e., the names of the physical units of each signal), and these are also copied to the output header file. 
     * Spaces embedded within unit names are written as underscores in the header file.
     * Lines are identified by line number. The first line of input not containing any alphabetic character is line 0. Similarly, columns are identified by column number, and the leftmost column is column 0. 
     * Columns may be selected in any order, and any given column may be selected more than once, or omitted. The order of column arguments determines the order of the signals in the output (data from the first column specified are written as signal 0, etc.) 
     * If an entry in a specified column is "-" (i.e., flagged as missing or invalid), or if an entry in a specified column is any other non-numeric value, wrsamp records it as an invalid sample in its output.
     * If line 0 appears to begin with a timestamp (a field of the form [hh:mm:ss.sss dd/mm/yyyy]), wrsamp records it as the base time (starting time) in the output header file. 
	 * 
	 * @param sInputFile - file name of the text file signal file to analyze.
	 * @param sPath - Produce output in CSV (comma-separated value) format (default: write output in tab-separated columns).
	 * @param sAnnotator - Check that each input line contains the same number of fields. (This test is normally disabled, to allow for input files containing preambles, trailers, or occasional extra fields not intended to be read as samples.)  
	 * @param iStartTime - Dither the input before converting it to integer output, by adding a random value to each sample. The random values are selected from a triangular probability density function between -1 and +1. Dithering is appropriate whenever the output has a lower resolution than the input. Note that the RNG used to generate the pseudo-random values is started with a fixed seed, so that wrsamp�s output is strictly reproducible. 
	 *                  Change the seed in the source and recompile to obtain a different realization of dither if desired.  
	 * @param bSummary - Specify the sampling frequency (in samples per second per signal) for the output signals (default: 250). This option is useful only in conjunction with -o, since it affects the output header file only. 
	 *                           This option has no effect on the output signal file, which contains one sample per signal for each line of input. 
	 *                           If you wish to change the sampling frequency in the signal file, see xform(1) . 
	 * @param iRate - Specify the gain (in A/D units per millivolt) for the output signals (default: 200). 
	 *                   To specify different gains for each output signal, provide a quoted list of values in place of n (see the examples below). 
	 *                   This option is useful only in conjunction with -o, since it affects the output header file only. 
	 *                   This option has no effect on the output signal file. If you wish to rescale samples in the signal file, use -x.  
	 * @param iEndTime - Print column headings (signal names on the first line, units on the second). 
	 * 						 The names of some signals are too wide to fit in the columns; such names are shortened by omitting the initial characters 
	 * 						 (since names of related signals often differ only at the end, this helps to make the columns identifiable). 
	 * 						 Names of units are shortened when necessary by omitting the final characters, since the initial characters are usually most important for distinguishing different units.      
	 * @param sOutputFile
	 * 
	 * Note:  The input file from the -i is not necessary.  The default input is from the stdin.  
	 *        Also, since input and output files are passed in from the web service, this function will be reworked to take those values in as parameters instead of in the form the
	 *        man page uses.  The command string will be built here.
	 *        Also note that we will need to create canned data for now until we get version 2 of the rdsamp function working (or the file output from version 1). 

	 * 
	 * @return
	 */	
	public boolean nguess(String sInputFile, String sPath, String sAnnotator, int iStartTime, double dQInterval, int iEndTime, String sOutputName){
		boolean bRet = true;
		debugPrintln("nguess()");
		debugPrintln("- sInputFile:" + sInputFile);
		debugPrintln("- sPath:" + sPath);
		debugPrintln("- bAnnotator:" + sAnnotator);
		debugPrintln("- bStartTime:" + iStartTime);  		
		debugPrintln("- dQInterval:" + dQInterval);
		debugPrintln("- iRate:" + iEndTime);
		debugPrintln("- sOutputName:" + sOutputName);
		
		try {
		
			String[] asEnvVar = new String[0];  
			
			// build command string
			int iIndexPeriod = sInputFile.lastIndexOf(".");
			String sRecord = sInputFile.substring(0, iIndexPeriod);
			
			//sOutputFile = sRecord;
			
			String sCommand = "nguess -r " + sPath + sRecord; // record name
			
			sCommand += " -a " + sAnnotator;
			if(iStartTime > 0) sCommand += " -f " + iStartTime;
	
			if(dQInterval > 0) {
				sCommand += " -m " + dQInterval;	
			}
	
			if(sOutputName != null && !sOutputName.equals("")){
				sCommand += " -o " + sOutputName;
			}else{
				sOutputName = sRecord + "_nguess";
			}
			
			if(iEndTime > 0) sCommand += " -t " + iEndTime;
			
			bRet = executeCommand(sCommand, asEnvVar, WORKING_DIR);
			
			bRet &= stdErrorHandler();
			
			if(bRet){
				stdReturnHandler();
				//set first output file to output generated by the sigamp command
				outputFilenames = new String[1];
				debugPrintln("- sOutputName:" + sOutputName);
				outputFilenames[0] = sPath + sRecord + "." + sOutputName;
			}else{
				debugPrintln("- Encountered errors.");
			}			
		
		} catch (Exception e) {
			bRet = false;
			log.error(e.getMessage());
		}
		
		return bRet;
	}
	
	/** Runs the Physionet ann2rr tool to take in text input and convert it into a WFDB record.
	 *  This converts annotation files to interval lists.
	 *  
	 * @param sInputFile - file name of the text file signal file to analyze.
	 * @param path - Produce output in CSV (comma-separated value) format (default: write output in tab-separated columns).
	 * @param bAllIntervals -A Print all intervals between annotations. 
	 * @param bConsecutive -c Print intervals between consecutive valid annotations only.
	 * @param startTime -f Begin at the specified time. 
	 * @param sIntervalFormat -i Print intervals in the specified format. 
	 * @param sMneumonicsEnd -p type [ type ... ] Print intervals ended by annotations of the specified types only.
	 * @param sMneumonicsBegin -P type [ type ... ] Print intervals begun by annotations of the specified types only. 
	 * @param endTime -t Stop at the specified time.     
	 * @param sFinalTimesFormat -v format Print final times in the specified format.
	 * @param sInitialTimesFormat -V format  Print initial times in the specified format.
	 * @param bFinalAnnotations -w Print final annotations.
	 * @param bInitialAnnotations -W Print initial annotations.
	 * @param sOutputName - Desired name of the output file, the extension ".rr" will be appended.
	 * 
	 * @return
	 */	
	public boolean ann2rr(String sInputFile, String path, 
			String annotator, boolean bAllIntervals, boolean bConsecutive, int startTime, 
			String sIntervalFormat, String sMneumonicsEnd, String sMneumonicsBegin, int endTime, String sFinalTimesFormat, 
			String sInitialTimesFormat, boolean bFinalAnnotations, boolean bInitialAnnotations, String sOutputName){
		boolean bRet = true;
		debugPrintln("ann2rr()");
		debugPrintln("- sInputFile:" + sInputFile);
		debugPrintln("- sPath:" + path);
		debugPrintln("- bAllInverals:" + bAllIntervals);
		debugPrintln("- bConsecutive:" + bConsecutive);
		debugPrintln("- bStartTime:" + startTime);  		
		debugPrintln("- sIntervalFormat:" + sIntervalFormat);
		debugPrintln("- sMneumonicsEnd:" + sMneumonicsEnd);
		debugPrintln("- sMneumonicsBegin:" + sMneumonicsBegin);
		debugPrintln("- iEndTime:" + endTime);
		debugPrintln("- sFinalTimesFormat:" + sFinalTimesFormat);
		debugPrintln("- sInitialTimesFormat:" + sInitialTimesFormat);
		debugPrintln("- bFinalAnnotations:" + bFinalAnnotations);
		debugPrintln("- bInitialAnnotations:" + bInitialAnnotations);
		debugPrintln("- sOutputName:" + sOutputName);

		try {

			String[] envVar = new String[0];  

			// build command string
			int iIndexPeriod = sInputFile.lastIndexOf(".");
			String sRecord = sInputFile.substring(0, iIndexPeriod);

			String command = "ann2rr -r " + path + sRecord ; // record name
			
			command += " -a " + annotator;
			
			if (bAllIntervals) {
				command += " -A"; // Print all intervals between annotations. This option overrides the -c and -p options. 
			} else {
				if (bConsecutive) {
					command += " -c"; // Print intervals between consecutive valid annotations only.
				}

				if (sMneumonicsEnd != null) {
					command += " -p " + sMneumonicsEnd;
				}
			}

			if(startTime > 0) command += " -f " + startTime;

			if(sIntervalFormat != null && !sIntervalFormat.equals("")){
				command += " -i " + sIntervalFormat;
			}

			if(sMneumonicsBegin != null &&  !sMneumonicsBegin.equals("")){
				command += " -P " + sMneumonicsBegin;
			}

			if(endTime > 0){ 
				command += " -t " + endTime;
			}

			if(sFinalTimesFormat != null && !sFinalTimesFormat.equals("")){
				command += " -v " + sFinalTimesFormat;
			}

			if(sInitialTimesFormat != null && !sInitialTimesFormat.equals("")){
				command += " -V " + sInitialTimesFormat;
			}

			if(bFinalAnnotations){
				command += " -w";
			}

			if(bInitialAnnotations){
				command += " -W";
			}

			bRet = executeCommand(command, envVar, WORKING_DIR);

			bRet &= stdErrorHandler();
			
			if(bRet){
				stdReturnHandler(path + sOutputName + ".rr");
				//set first output file.
				outputFilenames = new String[1];
				debugPrintln("- sOutputName:" + sOutputName);
				outputFilenames[0] = path + sOutputName + ".rr";
			}else{
				debugPrintln("- Encountered errors.");
			}			

		} catch (Exception e) {
			bRet = false;
			log.error(e.getMessage());
		}

		return bRet;
	}
	
	/** Runs the Physionet pnnlist tool to derive pNNx statistics from an annotation interval list or an annotation file .
	 * 
	 */
	public boolean pnnlist(String sInputFile, String sPath, int iStartTime, int iEndTime, String sAnnotator, double iInc, boolean bPercents, boolean bSeparateDistributions, String sOutputName){
		boolean bRet = true;
		debugPrintln("pnnlist()");
		debugPrintln("- sInputFile:" + sInputFile);
		debugPrintln("- sPath:" + sPath);
		debugPrintln("- bAnnotator:" + sAnnotator);
		debugPrintln("- iInc:" + iInc);  		
		debugPrintln("- dQInterval:" + bPercents);
		debugPrintln("- iRate:" + bSeparateDistributions);
		debugPrintln("- sOutputName:" + sOutputName);
		
		try {
		
		String[] asEnvVar = new String[0];  
		
		// build command string
		int iIndexPeriod = sInputFile.lastIndexOf(".");
		String sRecord = sInputFile.substring(0, iIndexPeriod);
		
		//sOutputFile = sRecord;
		
		getDirs();
		
//		String sCommand = "pnnlist";
//		if(iInc > 0) sCommand += " -i " + iInc;
//		if(bPercents) sCommand += " -p";	
//		if(bSeparateDistributions) sCommand += " -s";

		String sCommand = " pNNx -r " + sPath + sRecord + " -a " + sAnnotator;
		if(iStartTime > 0) sCommand += " -f " + iStartTime;
		if(iEndTime > 0) sCommand += " -t " + iEndTime;
		debugPrintln("- sCommand:" + sCommand);
		
		
		bRet = executeCommand(sCommand, asEnvVar, WORKING_DIR);
		
		bRet &= stdErrorHandler();
		
		stdReturnHandler(sPath + sOutputName + ".pnn");
		
		if(bRet){
			outputFilenames = new String[1];
			debugPrintln("- sOutputName:" + sOutputName);
			outputFilenames[0] = sPath + sOutputName + ".pnn";
		}else{
			debugPrintln("- Encountered errors.");
		}			
		
		} catch (Exception e) {
			bRet = false;
			log.error(e.getMessage());
		}
		
		return bRet;
	}
	
	private void getDirs() {
        File dir1 = new File(".");
        File dir2 = new File("..");
        try {
            debugPrintln("Current dir : " + dir1.getCanonicalPath());
            debugPrintln("Parent  dir : " + dir2.getCanonicalPath());
        } catch (Exception e) {
        	log.error(e.getMessage());
        }
    }

	@Override
	protected void processReturnLine(String arg0) {
		// TODO Auto-generated method stub
	}

	public boolean rdann(String inputName, String path, String annotator, Integer channel, String elapsedTime, String startTime, boolean printSummary, String num, String type,
						 String subType, String endTime, boolean printColumnHeading, boolean useAlternativeTimeFormat, String outputName) {
		
		boolean bRet = true;
		debugPrintln("ann2rr()");
		debugPrintln("- inputName:" + inputName);
		debugPrintln("- path:" + path);
		debugPrintln("- annotator:" + annotator);
		debugPrintln("- channel:" + channel);
		debugPrintln("- elapsedTime:" + elapsedTime);
		debugPrintln("- startTime:" + startTime);  		
		debugPrintln("- printSummary:" + printSummary);
		debugPrintln("- num:" + num);
		debugPrintln("- type:" + type);
		debugPrintln("- subType:" + subType);
		debugPrintln("- endTime:" + endTime);
		debugPrintln("- printColumnHeading:" + printColumnHeading);
		debugPrintln("- useAlternativeTimeFormat:" + useAlternativeTimeFormat);
		debugPrintln("- outputName:" + outputName);

		try {

			String[] envVar = new String[0];  

			// build command string
			int iIndexPeriod = inputName.lastIndexOf(".");
			String sRecord = inputName.substring(0, iIndexPeriod);

			String command = "rdann -r " + path + sRecord ; // record name
			
			command += " -a " + annotator;
			
			if (channel != null) {
				command += " -c"; //Print only those annotations with chan fields that match chan. 
			} 
			
			if(!useAlternativeTimeFormat){
				if(elapsedTime != null){
					command += " -e " + elapsedTime; //Print annotation times as elapsed times from the beginning of the record (default: rdann prints absolute times if the absolute time of the beginning of the record is defined, and elapsed times otherwise, unless the -x option has been given).
				}
			}else{
				command += " -x "; //Use an alternate time format for output (the first three columns are the elapsed times in seconds, in minutes, and in hours, replacing the hh:mm:ss and sample number columns in the default output). Note that this format is incompatible with wrann.
			}
			
			if(startTime != null){ 
				command += " -f " + startTime; //Begin at the specified time. By default, rdann starts at the beginning of the record; if modification labels are present, they are not printed unless -f 0 is given explicitly, however.
			}

			if(endTime != null){ 
				command += " -t " + endTime; //Stop at the specified time.
			}

			if(num != null && !num.equals("")){
				command += " -n " + num; //Print only those annotations with num fields that match num.
			}

			if(type != null && !type.equals("")){
				command += " -p " + type; //Print annotations of the specified types only.
			}

			if(subType != null && !subType.equals("")){
				command += " -s " + subType; //Print only those annotations with subtyp fields that match sub.
			}
			
			if(printSummary){
				command += " -h"; //Print a usage summary.
			}

			if(printColumnHeading){
				command += " -v"; //Print column headings.
			}

			bRet = executeCommand(command, envVar, WORKING_DIR);

			bRet &= stdErrorHandler();
			
			if(bRet){
				stdCSVReturnHandler(path + outputName + ".csv", new String[]{"Time", "Sample #","Type","Sub","Chan","Num","Aux"});
				//set first output file.
				outputFilenames = new String[1];
				debugPrintln("- sOutputName:" + outputName);
				outputFilenames[0] = path + outputName + ".csv";
			}else{
				debugPrintln("- Encountered errors.");
			}			

		} catch (Exception e) {
			bRet = false;
			log.error(e.getMessage());
		}

		return bRet;
	}

}
